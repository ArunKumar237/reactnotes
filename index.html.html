<html><head><style>/* =========================================
   A4 SETTINGS
========================================= */

@page {
  size: A4;
  margin: 22mm 18mm;
}

/* =========================================
   GLOBAL
========================================= */

* {
  box-sizing: border-box;
}

body {
  background-color: #000000;
  color: #e5e7eb;
  font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
  font-size: 13.5pt;
  line-height: 1.75;
  max-width: 900px;
  margin: auto;
  padding: 40px;
}

/* =========================================
   MAIN TITLE
========================================= */

h1 {
  font-size: 28pt;
  font-weight: 700;
  margin-bottom: 30px;
  padding-bottom: 15px;
  border-bottom: 4px solid #6366f1;
  color: #ffffff;
  letter-spacing: -0.5px;
  break-after: avoid-page;
}

/* =========================================
   SECTION HEADINGS
========================================= */

h2 {
  font-size: 19pt;
  margin-top: 45px;
  margin-bottom: 15px;
  padding: 10px 16px;
  border-left: 6px solid #6366f1;
  background: #0f172a;
  border-radius: 6px;
  color: #ffffff;
  break-after: avoid-page;
}

h3 {
  font-size: 15pt;
  margin-top: 25px;
  margin-bottom: 10px;
  color: #818cf8;
  break-after: avoid;
}

/* =========================================
   TEXT
========================================= */

p {
  margin-bottom: 14px;
  color: #d1d5db;
  text-align: justify;
}

strong {
  color: #ffffff;
  font-weight: 600;
}

/* =========================================
   LISTS
========================================= */

ul, ol {
  margin: 10px 0 15px 28px;
}

li {
  margin-bottom: 6px;
  break-inside: avoid;
}

/* =========================================
   CODE BLOCKS
========================================= */

pre {
  background: #0f172a;
  color: #f8fafc;
  padding: 18px;
  border-radius: 12px;
  font-size: 11.5pt;
  overflow-x: auto;
  margin: 20px 0;
  break-inside: avoid;
  border: 1px solid #1e293b;
  box-shadow: 0 8px 20px rgba(0,0,0,0.6);
}

code {
  font-family: "Fira Code", monospace;
  background: #1e293b;
  color: #93c5fd;
  padding: 3px 6px;
  border-radius: 6px;
  font-size: 11pt;
}

pre code {
  background: transparent;
  color: inherit;
  padding: 0;
}

/* =========================================
   TABLES
========================================= */

table {
  width: 100%;
  border-collapse: collapse;
  margin: 22px 0;
  font-size: 12.5pt;
  break-inside: avoid;
  border-radius: 10px;
  overflow: hidden;
  border: 1px solid #1e293b;
}

thead {
  background: #111827;
  color: #ffffff;
}

th, td {
  padding: 12px 14px;
  border-bottom: 1px solid #1f2937;
}

tbody tr:nth-child(even) {
  background: #0f172a;
}

/* =========================================
   HR
========================================= */

hr {
  border: none;
  border-top: 1px solid #1f2937;
  margin: 35px 0;
}

/* =========================================
   PAGE BREAK CONTROL
========================================= */
h1, h2, h3 {
  break-after: avoid-page;
  break-inside: avoid;
}

pre, table, blockquote {
  break-inside: avoid;
}

p, li {
  break-inside: avoid;
  orphans: 3;
  widows: 3;
}

/* Prevent headings at bottom of page */
h2, h3 {
  break-after: avoid;
}

/* Avoid splitting list items */
li {
  page-break-inside: avoid;
}


/* =========================================
   SMALL SCREEN PREVIEW
========================================= */

@media screen and (max-width: 768px) {
  body {
    padding: 20px;
    font-size: 13pt;
  }
}
</style></head><body><h1 id="-core-react-fundamentals-interview-q-a">üîπ Core React Fundamentals ‚Äî Interview Q&amp;A</h1>
<hr>
<h2 id="react">REACT</h2>
<p><strong>Q1: What is React?</strong></p>
<p>React is a <strong>JavaScript library</strong> developed by Facebook (now Meta) for building <strong>user interfaces</strong>, specifically for <strong>single-page applications</strong>. It allows developers to build <strong>reusable UI components</strong> that efficiently update and render when data changes. It focuses only on the <strong>view layer</strong> (the &quot;V&quot; in MVC).</p>
<hr>
<p><strong>Q2: Why React over plain JavaScript or other frameworks?</strong></p>
<ul>
<li><strong>Component-based architecture</strong> ‚Äî build encapsulated, reusable pieces of UI</li>
<li><strong>Virtual DOM</strong> ‚Äî minimizes expensive real DOM manipulations, making updates fast</li>
<li><strong>Declarative</strong> ‚Äî you describe <em>what</em> the UI should look like for a given state, and React figures out <em>how</em> to update the DOM</li>
<li><strong>Unidirectional data flow</strong> ‚Äî data flows from parent to child, making apps predictable and easier to debug</li>
<li><strong>Huge ecosystem</strong> ‚Äî massive community, libraries, and tooling support</li>
</ul>
<hr>
<p><strong>Q3: Is React a framework or a library? Why does this distinction matter?</strong></p>
<p>React is a <strong>library</strong>, not a framework. The distinction matters because:</p>
<ul>
<li>A <strong>framework</strong> (like Angular) provides a complete solution ‚Äî routing, HTTP calls, form handling, etc. It controls the flow of your application (Inversion of Control).</li>
<li>A <strong>library</strong> gives you tools to solve a specific problem but <strong>you control</strong> the flow. React only handles the <strong>view layer</strong>. For routing, state management, or API calls, you choose and plug in other libraries yourself.</li>
</ul>
<p>This gives React <strong>flexibility</strong> but means you need to make more architectural decisions.</p>
<hr>
<p><strong>Q4: What does &quot;declarative&quot; mean in the context of React?</strong></p>
<p>In <strong>imperative</strong> programming, you write step-by-step instructions to manipulate the DOM:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Imperative</span>
<span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'h1'</span>);
el.textContent = <span class="hljs-string">'Hello'</span>;
<span class="hljs-built_in">document</span>.body.appendChild(el);
</code></pre>
<p>In <strong>declarative</strong> programming (React&#39;s approach), you simply describe the <strong>desired outcome</strong>:</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Declarative</span>
<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
</code></pre>
<p>You tell React <strong>what</strong> you want, and React handles the <strong>how</strong> (DOM updates, diffing, etc.).</p>
<hr>
<p><strong>Q5: What is the difference between a Single Page Application (SPA) and a Multi-Page Application (MPA)?</strong></p>
<table>
<thead>
<tr>
<th>SPA</th>
<th>MPA</th>
</tr>
</thead>
<tbody>
<tr>
<td>Loads a <strong>single HTML page</strong> and dynamically rewrites content</td>
<td>Each interaction loads a <strong>new HTML page</strong> from the server</td>
</tr>
<tr>
<td>Faster user experience after initial load</td>
<td>Full page reload on every navigation</td>
</tr>
<tr>
<td>React, Angular, Vue are commonly used</td>
<td>Traditional server-rendered apps (PHP, Rails, etc.)</td>
</tr>
<tr>
<td>Routing happens on the <strong>client side</strong></td>
<td>Routing happens on the <strong>server side</strong></td>
</tr>
</tbody>
</table>
<p>React is typically used to build SPAs.</p>
<hr>
<h2 id="jsx">JSX</h2>
<p><strong>Q6: What is JSX?</strong></p>
<p>JSX stands for <strong>JavaScript XML</strong>. It is a <strong>syntax extension</strong> for JavaScript that lets you write HTML-like code inside JavaScript. It is <strong>not valid JavaScript</strong> ‚Äî browsers can&#39;t read it directly. Tools like <strong>Babel</strong> transpile JSX into regular JavaScript function calls.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// JSX</span>
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;

<span class="hljs-comment">// After Babel transpilation (React 17+)</span>
<span class="hljs-keyword">const</span> element = _jsx(<span class="hljs-string">'h1'</span>, { <span class="hljs-attr">children</span>: <span class="hljs-string">'Hello, World!'</span> });
</code></pre>
<hr>
<p><strong>Q7: Is JSX mandatory in React?</strong></p>
<p>No. JSX is <strong>syntactic sugar</strong>. You can write React without JSX using <code>React.createElement()</code>:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Without JSX</span>
<span class="hljs-keyword">const</span> element = React.createElement(<span class="hljs-string">'h1'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'Hello, World!'</span>);
</code></pre>
<p>But JSX is <strong>strongly recommended</strong> because it is more readable, intuitive, and closely resembles the final HTML output.</p>
<hr>
<p><strong>Q8: What are the rules/limitations of JSX?</strong></p>
<ol>
<li><strong>Must return a single root element</strong> ‚Äî you cannot return adjacent elements without a wrapper</li>
<li><strong>All tags must be closed</strong> ‚Äî including self-closing tags like <code>&lt;img /&gt;</code>, <code>&lt;input /&gt;</code></li>
<li><strong>Use <code>className</code> instead of <code>class</code></strong> ‚Äî because <code>class</code> is a reserved keyword in JS</li>
<li><strong>Use <code>htmlFor</code> instead of <code>for</code></strong> ‚Äî same reason</li>
<li><strong>JavaScript expressions</strong> inside JSX use <strong>curly braces <code>{}</code></strong></li>
<li><strong>Inline styles</strong> are written as objects with camelCase properties: <code>style={{ backgroundColor: &#39;red&#39; }}</code></li>
<li><strong>Cannot use <code>if/else</code> statements</strong> directly inside JSX (use ternary or logical <code>&amp;&amp;</code> instead)</li>
</ol>
<hr>
<p><strong>Q9: How do you embed JavaScript expressions in JSX?</strong></p>
<p>Using <strong>curly braces <code>{}</code></strong>:</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Rahul'</span>;
<span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;

<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Age: {age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Next year: {age + 1}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Is adult: {age &gt;= 18 ? 'Yes' : 'No'}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);
</code></pre>
<p>You can embed any <strong>valid JavaScript expression</strong> ‚Äî variables, function calls, ternary operators, array methods, etc. But <strong>not statements</strong> like <code>if</code>, <code>for</code>, <code>while</code>.</p>
<hr>
<h2 id="components">COMPONENTS</h2>
<p><strong>Q10: What are components in React?</strong></p>
<p>Components are the <strong>building blocks</strong> of a React application. They are <strong>independent, reusable pieces of UI</strong> that accept inputs (called <strong>props</strong>) and return <strong>React elements</strong> describing what should appear on the screen.</p>
<p>Think of them like <strong>custom HTML tags</strong> that encapsulate their own structure, logic, and styling.</p>
<hr>
<p><strong>Q11: What are the types of components in React?</strong></p>
<p>Two types:</p>
<ol>
<li><strong>Functional Components</strong> ‚Äî JavaScript functions that return JSX</li>
<li><strong>Class Components</strong> ‚Äî ES6 classes that extend <code>React.Component</code> and have a <code>render()</code> method</li>
</ol>
<p>Since React 16.8 (introduction of Hooks), <strong>functional components</strong> are the standard and recommended approach.</p>
<hr>
<h2 id="functional-components">FUNCTIONAL COMPONENTS</h2>
<p><strong>Q12: What is a functional component? Give an example.</strong></p>
<p>A functional component is a <strong>plain JavaScript function</strong> that accepts <code>props</code> as an argument and returns <strong>JSX</strong>.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">{ name }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-comment">// Arrow function style</span>
<span class="hljs-keyword">const</span> Greeting = <span class="hljs-function">(<span class="hljs-params">{ name }</span>) =&gt;</span> &lt;h1&gt;Hello, {name}!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
</code></pre>
<p>Before Hooks, functional components were called &quot;stateless&quot; components because they couldn&#39;t manage state. After Hooks, they can do <strong>everything</strong> class components can do.</p>
<hr>
<h2 id="class-components">CLASS COMPONENTS</h2>
<p><strong>Q13: What is a class component? Give an example.</strong></p>
<p>A class component is an <strong>ES6 class</strong> that extends <code>React.Component</code> and must have a <code>render()</code> method that returns JSX.</p>
<pre><code class="lang-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> &lt;h1&gt;<span class="hljs-type">Hello</span>, {<span class="hljs-keyword">this</span>.props.name}!&lt;/h1&gt;;
  }
}
</code></pre>
<hr>
<p><strong>Q14: What are the key differences between functional and class components?</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Functional Component</th>
<th>Class Component</th>
</tr>
</thead>
<tbody>
<tr>
<td>Syntax</td>
<td>Plain function</td>
<td>ES6 class with <code>render()</code></td>
</tr>
<tr>
<td>State</td>
<td><code>useState</code> hook</td>
<td><code>this.state</code> + <code>this.setState</code></td>
</tr>
<tr>
<td>Lifecycle methods</td>
<td><code>useEffect</code> hook</td>
<td><code>componentDidMount</code>, <code>componentDidUpdate</code>, etc.</td>
</tr>
<tr>
<td><code>this</code> keyword</td>
<td>Not needed</td>
<td>Required (<code>this.props</code>, <code>this.state</code>)</td>
</tr>
<tr>
<td>Performance</td>
<td>Slightly better (no class overhead)</td>
<td>Slightly heavier</td>
</tr>
<tr>
<td>Boilerplate</td>
<td>Less</td>
<td>More</td>
</tr>
<tr>
<td>Current preference</td>
<td>‚úÖ <strong>Recommended</strong></td>
<td>Used in legacy codebases</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Q15: Can we use lifecycle methods in functional components?</strong></p>
<p>Not directly. Functional components don&#39;t have traditional lifecycle methods like <code>componentDidMount</code>. However, the <strong><code>useEffect</code> hook</strong> covers all lifecycle scenarios:</p>
<ul>
<li><code>componentDidMount</code> ‚Üí <code>useEffect(() =&gt; {}, [])</code></li>
<li><code>componentDidUpdate</code> ‚Üí <code>useEffect(() =&gt; {}, [dependency])</code></li>
<li><code>componentWillUnmount</code> ‚Üí <code>useEffect(() =&gt; { return () =&gt; cleanup }, [])</code></li>
</ul>
<hr>
<h2 id="props">PROPS</h2>
<p><strong>Q16: What are props in React?</strong></p>
<p>Props (short for <strong>properties</strong>) are the mechanism for <strong>passing data from a parent component to a child component</strong>. They are <strong>read-only</strong> ‚Äî a child component <strong>cannot modify</strong> the props it receives.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Parent</span>
&lt;UserCard name=<span class="hljs-string">"Rahul"</span> age={<span class="hljs-number">25</span>} /&gt;

<span class="hljs-comment">// Child</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserCard</span>(<span class="hljs-params">{ name, age }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{name} is {age} years old<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}
</code></pre>
<hr>
<p><strong>Q17: Are props mutable or immutable? Why?</strong></p>
<p>Props are <strong>immutable</strong> (read-only). A child component should <strong>never modify</strong> its own props. This ensures:</p>
<ul>
<li><strong>Predictability</strong> ‚Äî the parent is the single source of truth</li>
<li><strong>Unidirectional data flow</strong> ‚Äî data flows top-down, making the app easier to debug</li>
<li><strong>Pure function behavior</strong> ‚Äî same props always produce the same output</li>
</ul>
<p>If a component needs to change data, it should use <strong>state</strong>, not mutate props.</p>
<hr>
<p><strong>Q18: Can you pass functions as props?</strong></p>
<p>Yes! This is one of the most common patterns for <strong>child-to-parent communication</strong>:</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> {
    alert(message);
  };

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span> /&gt;</span>;
}

function Child({ onClick }) {
  return <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onClick('Hello from Child!')}&gt;Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>;
}</span>
</code></pre>
<hr>
<p><strong>Q19: What are default props?</strong></p>
<p>Default values assigned to props when the parent doesn&#39;t provide them:</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">{ name = <span class="hljs-string">'Guest'</span> }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-comment">// &lt;Greeting /&gt;        ‚Üí renders "Hello, Guest!"</span>
<span class="hljs-comment">// &lt;Greeting name="Rahul" /&gt; ‚Üí renders "Hello, Rahul!"</span>
</code></pre>
<hr>
<p><strong>Q20: What is <code>props.children</code>?</strong></p>
<p><code>props.children</code> refers to whatever content is placed <strong>between</strong> the opening and closing tags of a component:</p>
<pre><code class="lang-jsx">function Card({ children }) {
  return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"card"</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;
}

// Usage
<span class="hljs-tag">&lt;<span class="hljs-name">Card</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Some content here<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span>
</code></pre>
<p>Here, the <code>&lt;h2&gt;</code> and <code>&lt;p&gt;</code> are the <code>children</code> of <code>Card</code>. This pattern is commonly used for <strong>wrapper/layout components</strong>.</p>
<hr>
<h2 id="state">STATE</h2>
<p><strong>Q21: What is state in React?</strong></p>
<p>State is a <strong>built-in object</strong> that holds data that belongs to a component and <strong>can change over time</strong>. When state changes, React <strong>re-renders</strong> the component to reflect the updated data in the UI.</p>
<p>Unlike props (which are passed from outside), state is <strong>managed internally</strong> by the component itself.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}
</code></pre>
<hr>
<p><strong>Q22: What is the difference between props and state?</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Props</th>
<th>State</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source</td>
<td>Passed from <strong>parent</strong></td>
<td>Managed <strong>within</strong> the component</td>
</tr>
<tr>
<td>Mutability</td>
<td><strong>Immutable</strong> (read-only)</td>
<td><strong>Mutable</strong> (can be updated)</td>
</tr>
<tr>
<td>Purpose</td>
<td>Configure/customize a component</td>
<td>Track dynamic/changing data</td>
</tr>
<tr>
<td>Triggers re-render</td>
<td>Only when parent re-renders with new props</td>
<td>Yes, when <code>setState</code>/<code>useState</code> updater is called</td>
</tr>
<tr>
<td>Who controls it</td>
<td>Parent component</td>
<td>The component itself</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Q23: Can we modify state directly? Why or why not?</strong></p>
<p><strong>Never modify state directly.</strong></p>
<pre><code class="lang-jsx"><span class="hljs-comment">// ‚ùå WRONG ‚Äî will NOT trigger re-render</span>
<span class="hljs-keyword">this</span>.state.<span class="hljs-keyword">count</span> = <span class="hljs-number">5</span>;       <span class="hljs-comment">// Class component</span>
<span class="hljs-keyword">count</span> = <span class="hljs-number">5</span>;                   <span class="hljs-comment">// Functional component</span>

<span class="hljs-comment">// ‚úÖ CORRECT</span>
<span class="hljs-keyword">this</span>.setState({ <span class="hljs-keyword">count</span>: <span class="hljs-number">5</span> }); <span class="hljs-comment">// Class component</span>
setCount(<span class="hljs-number">5</span>);                  <span class="hljs-comment">// Functional component</span>
</code></pre>
<p>Direct mutation <strong>bypasses React&#39;s rendering mechanism</strong>. React doesn&#39;t know the state changed, so the UI won&#39;t update. You must always use the setter function so React can:</p>
<ol>
<li>Schedule a re-render</li>
<li>Diff the old and new Virtual DOM</li>
<li>Efficiently update the real DOM</li>
</ol>
<hr>
<h2 id="setstate">setState</h2>
<p><strong>Q24: How does <code>setState</code> work in class components?</strong></p>
<p><code>setState</code> is used to <strong>update state</strong> and <strong>trigger re-rendering</strong> in class components. Key behaviors:</p>
<ol>
<li><strong>Asynchronous</strong> ‚Äî React batches multiple <code>setState</code> calls for performance, so state may not update immediately</li>
<li><strong>Shallow merge</strong> ‚Äî it merges the new state with the existing state (unlike <code>useState</code> which replaces)</li>
</ol>
<pre><code class="lang-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = { count: <span class="hljs-number">0</span>, name: <span class="hljs-symbol">'Rahu</span>l' };

  increment = () =&gt; {
    <span class="hljs-comment">// Only updates 'count', 'name' stays intact (shallow merge)</span>
    <span class="hljs-keyword">this</span>.setState({ count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span> });
  };

  render() {
    <span class="hljs-keyword">return</span> &lt;button onClick={<span class="hljs-keyword">this</span>.increment}&gt;<span class="hljs-type">Count</span>: {<span class="hljs-keyword">this</span>.state.count}&lt;/button&gt;;
  }
}
</code></pre>
<hr>
<p><strong>Q25: Why is <code>setState</code> asynchronous? What problem does that cause?</strong></p>
<p>React <strong>batches</strong> multiple <code>setState</code> calls into a single re-render for <strong>performance</strong> reasons. This means <code>this.state</code> may not reflect the updated value immediately after calling <code>setState</code>.</p>
<p><strong>Problem:</strong></p>
<pre><code class="lang-jsx">this.<span class="hljs-built_in">set</span>State({ count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span> });
this.<span class="hljs-built_in">set</span>State({ count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span> });
// count only increases by <span class="hljs-number">1</span>, not <span class="hljs-number">2</span>!
// Both calls read the same stale value of this.<span class="hljs-keyword">state</span>.count
</code></pre>
<p><strong>Solution ‚Äî Use the functional/updater form:</strong></p>
<pre><code class="lang-jsx"><span class="hljs-keyword">this</span>.setState(prevState =&gt; ({ <span class="hljs-keyword">count</span>: prevState.<span class="hljs-keyword">count</span> + <span class="hljs-number">1</span> }));
<span class="hljs-keyword">this</span>.setState(prevState =&gt; ({ <span class="hljs-keyword">count</span>: prevState.<span class="hljs-keyword">count</span> + <span class="hljs-number">1</span> }));
<span class="hljs-comment">// count correctly increases by 2</span>
</code></pre>
<p>The updater function always receives the <strong>latest previous state</strong>, avoiding stale state issues.</p>
<hr>
<p><strong>Q26: Does <code>useState</code> also behave asynchronously?</strong></p>
<p>Yes. <code>useState</code> setter also <strong>batches updates</strong> (especially since React 18, which introduced <strong>automatic batching</strong> even in promises, timeouts, and event handlers).</p>
<p>Same problem, same solution:</p>
<pre><code class="lang-jsx">const [<span class="hljs-built_in">count</span>, setCount] = useState(<span class="hljs-number">0</span>);

<span class="hljs-comment">// ‚ùå Stale state</span>
setCount(<span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>);
setCount(<span class="hljs-built_in">count</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// still uses old count</span>

<span class="hljs-comment">// ‚úÖ Correct</span>
setCount(<span class="hljs-built_in">prev</span> =&gt; <span class="hljs-built_in">prev</span> + <span class="hljs-number">1</span>);
setCount(<span class="hljs-built_in">prev</span> =&gt; <span class="hljs-built_in">prev</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// correctly uses latest value</span>
</code></pre>
<hr>
<p><strong>Q27: What is the difference between <code>setState</code> in class components and <code>useState</code> setter in functional components?</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>this.setState</code> (Class)</th>
<th><code>useState</code> setter (Functional)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Merging</td>
<td><strong>Shallow merges</strong> with existing state</td>
<td><strong>Replaces</strong> the state entirely</td>
</tr>
<tr>
<td>Callback</td>
<td>Accepts a <strong>callback</strong> as 2nd argument <code>this.setState({}, callback)</code></td>
<td>No callback ‚Äî use <code>useEffect</code> instead</td>
</tr>
<tr>
<td>Syntax</td>
<td><code>this.setState({ key: value })</code></td>
<td><code>setValue(newValue)</code></td>
</tr>
</tbody>
</table>
<p>Shallow merge example:</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Class ‚Äî shallow merge</span>
<span class="hljs-keyword">this</span>.state = { <span class="hljs-string">name:</span> <span class="hljs-string">'Rahul'</span>, <span class="hljs-string">age:</span> <span class="hljs-number">25</span> };
<span class="hljs-keyword">this</span>.setState({ <span class="hljs-string">age:</span> <span class="hljs-number">26</span> });
<span class="hljs-comment">// Result: { name: 'Rahul', age: 26 } ‚úÖ 'name' is preserved</span>

<span class="hljs-comment">// Functional ‚Äî replaces entirely</span>
const [user, setUser] = useState({ <span class="hljs-string">name:</span> <span class="hljs-string">'Rahul'</span>, <span class="hljs-string">age:</span> <span class="hljs-number">25</span> });
setUser({ <span class="hljs-string">age:</span> <span class="hljs-number">26</span> });
<span class="hljs-comment">// Result: { age: 26 } ‚ùå 'name' is gone!</span>

<span class="hljs-comment">// Fix: spread the previous state</span>
setUser(prev =&gt; ({ ...prev, <span class="hljs-string">age:</span> <span class="hljs-number">26</span> }));
<span class="hljs-comment">// Result: { name: 'Rahul', age: 26 } ‚úÖ</span>
</code></pre>
<hr>
<h2 id="virtual-dom">VIRTUAL DOM</h2>
<p><strong>Q28: What is the Virtual DOM?</strong></p>
<p>The Virtual DOM is a <strong>lightweight JavaScript representation</strong> (a plain JS object tree) of the actual/real DOM. It is a <strong>copy</strong> of the real DOM that React keeps in memory.</p>
<p>When state or props change:</p>
<ol>
<li>React creates a <strong>new Virtual DOM tree</strong> reflecting the updated UI</li>
<li>React <strong>compares (diffs)</strong> the new Virtual DOM with the previous one</li>
<li>It calculates the <strong>minimum set of changes</strong> needed</li>
<li>It <strong>updates only those specific parts</strong> of the real DOM</li>
</ol>
<p>This process is much faster than directly manipulating the real DOM because real DOM operations are <strong>expensive</strong> (layout recalculation, repainting, etc.).</p>
<hr>
<p><strong>Q29: Why is real DOM manipulation slow?</strong></p>
<p>When you modify the real DOM:</p>
<ul>
<li>The browser must <strong>recalculate styles</strong> (CSS recalculation)</li>
<li><strong>Reflow/Layout</strong> ‚Äî recalculates positions and sizes of elements</li>
<li><strong>Repaint</strong> ‚Äî redraws pixels on screen</li>
<li>These are <strong>synchronous and blocking</strong> operations</li>
</ul>
<p>Even changing one small element can trigger layout recalculation for a large part of the page. React&#39;s Virtual DOM minimizes these expensive operations by <strong>batching and minimizing</strong> real DOM updates.</p>
<hr>
<p><strong>Q30: Virtual DOM vs Real DOM ‚Äî key differences?</strong></p>
<table>
<thead>
<tr>
<th>Virtual DOM</th>
<th>Real DOM</th>
</tr>
</thead>
<tbody>
<tr>
<td>A JS object (in-memory representation)</td>
<td>The actual browser DOM</td>
</tr>
<tr>
<td>Updates are <strong>cheap</strong></td>
<td>Updates are <strong>expensive</strong></td>
</tr>
<tr>
<td>Can <strong>batch</strong> multiple updates</td>
<td>Every update triggers reflow/repaint</td>
</tr>
<tr>
<td>React diffs and applies <strong>minimal changes</strong></td>
<td>Direct manipulation updates everything</td>
</tr>
<tr>
<td>Not rendered on screen directly</td>
<td>Directly rendered by the browser</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="reconciliation">RECONCILIATION</h2>
<p><strong>Q31: What is Reconciliation in React?</strong></p>
<p>Reconciliation is React&#39;s <strong>algorithm/process of comparing</strong> the old Virtual DOM tree with the new one (after a state or prop change) and determining the <strong>minimum number of operations</strong> needed to update the real DOM.</p>
<p>It is essentially the <strong>&quot;diffing algorithm&quot;</strong> behind React&#39;s efficient rendering.</p>
<hr>
<p><strong>Q32: How does React&#39;s diffing algorithm work?</strong></p>
<p>React uses two key <strong>heuristics</strong> to make the O(n¬≥) tree comparison problem into an O(n) operation:</p>
<ol>
<li><p><strong>Different element types produce different trees</strong> ‚Äî If the root element type changes (e.g., <code>&lt;div&gt;</code> ‚Üí <code>&lt;span&gt;</code>), React <strong>destroys</strong> the old tree and builds a new one from scratch. No further diffing.</p>
</li>
<li><p><strong>The <code>key</code> prop helps identify stable elements</strong> ‚Äî When rendering lists, React uses <code>key</code> to match elements between the old and new tree. This helps React know which items were added, removed, or reordered.</p>
</li>
</ol>
<p><strong>Same type elements:</strong> React keeps the same DOM node and only updates the <strong>changed attributes/props</strong>.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Old</span>
&lt;<span class="hljs-selector-tag">div</span> className=<span class="hljs-string">"old"</span> /&gt;

<span class="hljs-comment">// New</span>
&lt;<span class="hljs-selector-tag">div</span> className=<span class="hljs-string">"new"</span> /&gt;

<span class="hljs-comment">// React only updates the className attribute, doesn't recreate the element</span>
</code></pre>
<hr>
<h2 id="rendering">RENDERING</h2>
<p><strong>Q33: What triggers a re-render in React?</strong></p>
<p>A component re-renders when:</p>
<ol>
<li><strong>Its state changes</strong> ‚Äî via <code>setState</code> or <code>useState</code> setter</li>
<li><strong>Its props change</strong> ‚Äî parent re-renders and passes new props</li>
<li><strong>Its parent re-renders</strong> ‚Äî even if the child&#39;s props haven&#39;t changed (unless optimized with <code>React.memo</code>)</li>
<li><strong>Context value changes</strong> ‚Äî if the component consumes a context that updates</li>
<li><strong><code>forceUpdate()</code> is called</strong> ‚Äî in class components (not recommended)</li>
</ol>
<hr>
<p><strong>Q34: What is the difference between the initial render and a re-render?</strong></p>
<p><strong>Initial render:</strong></p>
<ul>
<li>Component runs for the <strong>first time</strong></li>
<li>React creates the Virtual DOM tree</li>
<li>React builds the <strong>actual DOM</strong> from scratch and inserts it into the page</li>
</ul>
<p><strong>Re-render:</strong></p>
<ul>
<li>Triggered by state/props change</li>
<li>React creates a <strong>new</strong> Virtual DOM tree</li>
<li>React <strong>diffs</strong> new tree with the old tree (reconciliation)</li>
<li>React updates <strong>only the changed parts</strong> of the real DOM</li>
</ul>
<hr>
<p><strong>Q35: Does re-rendering mean the entire DOM is re-created?</strong></p>
<p><strong>No.</strong> This is a common misconception. Re-render means React <strong>re-executes the component function</strong> (or <code>render()</code> method) to produce a new Virtual DOM tree. React then diffs this with the previous Virtual DOM and updates <strong>only the specific DOM nodes</strong> that changed. This is why React is performant.</p>
<hr>
<h2 id="conditional-rendering">CONDITIONAL RENDERING</h2>
<p><strong>Q36: What is conditional rendering in React?</strong></p>
<p>Conditional rendering means showing or hiding UI elements <strong>based on certain conditions</strong>, just like <code>if/else</code> in JavaScript. React doesn&#39;t have special directives (like Angular&#39;s <code>*ngIf</code>); instead, you use plain <strong>JavaScript expressions</strong>.</p>
<hr>
<p><strong>Q37: What are the different ways to do conditional rendering?</strong></p>
<p><strong>1. if/else (outside JSX)</strong></p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">{ isLoggedIn }</span>) </span>{
  <span class="hljs-keyword">if</span> (isLoggedIn) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome back!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
  }
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Please sign in.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}
</code></pre>
<p><strong>2. Ternary operator (inside JSX)</strong></p>
<pre><code class="lang-jsx"><span class="hljs-keyword">return</span> &lt;h1&gt;{isLoggedIn ? <span class="hljs-symbol">'Welcome</span> back!' : '<span class="hljs-type">Please</span> sign <span class="hljs-keyword">in</span>.'}&lt;/h1&gt;;
</code></pre>
<p><strong>3. Logical AND <code>&amp;&amp;</code> (render or nothing)</strong></p>
<pre><code class="lang-jsx"><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    {isLoggedIn &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">LogoutButton</span> /&gt;</span>}
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);
<span class="hljs-comment">// If isLoggedIn is true, renders LogoutButton. Otherwise, renders nothing.</span>
</code></pre>
<p><strong>4. Logical OR <code>||</code> (fallback)</strong></p>
<pre><code class="lang-jsx"><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{username || 'Guest'}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
</code></pre>
<p><strong>5. Switch/case or object lookup</strong> ‚Äî for multiple conditions</p>
<hr>
<p><strong>Q38: What is the pitfall of using <code>&amp;&amp;</code> for conditional rendering?</strong></p>
<p>When the left-hand side is <strong><code>0</code></strong> (a falsy but valid number), React will <strong>render <code>0</code></strong> on screen instead of rendering nothing:</p>
<pre><code class="lang-jsx">const <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;

<span class="hljs-comment">// ‚ùå Renders "0" on screen</span>
<span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">div</span>&gt;{<span class="hljs-keyword">count</span> &amp;&amp; &lt;span&gt;Items: {<span class="hljs-keyword">count</span>}&lt;<span class="hljs-regexp">/span&gt;}&lt;/</span><span class="hljs-keyword">div</span>&gt;;

<span class="hljs-comment">// ‚úÖ Fix: explicitly check with a boolean</span>
<span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">div</span>&gt;{<span class="hljs-keyword">count</span> &gt; <span class="hljs-number">0</span> &amp;&amp; &lt;span&gt;Items: {<span class="hljs-keyword">count</span>}&lt;<span class="hljs-regexp">/span&gt;}&lt;/</span><span class="hljs-keyword">div</span>&gt;;
</code></pre>
<p>This happens because <code>0</code> is falsy in JS, so <code>0 &amp;&amp; &lt;Component /&gt;</code> evaluates to <code>0</code>, and React renders the number <code>0</code>.</p>
<hr>
<h2 id="lists-keys">LISTS &amp; KEYS</h2>
<p><strong>Q39: How do you render a list in React?</strong></p>
<p>Using the JavaScript <code>map()</code> method to transform an array of data into an array of JSX elements:</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">'Apple'</span>, <span class="hljs-string">'Banana'</span>, <span class="hljs-string">'Cherry'</span>];

<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {fruits.map((fruit, index) =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span>{fruit}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);
</code></pre>
<hr>
<p><strong>Q40: What are keys in React? Why are they important?</strong></p>
<p>Keys are <strong>unique identifiers</strong> assigned to elements in a list. They help React&#39;s <strong>reconciliation algorithm</strong> identify which items have been <strong>added, changed, or removed</strong>.</p>
<p>Without keys (or with improper keys), React can&#39;t efficiently track list items, leading to:</p>
<ul>
<li><strong>Incorrect UI updates</strong> (wrong components may be reused)</li>
<li><strong>Performance issues</strong> (React may re-create elements unnecessarily)</li>
<li><strong>State bugs</strong> (state may get attached to the wrong item)</li>
</ul>
<hr>
<p><strong>Q41: Why is using <code>index</code> as a key a bad practice?</strong></p>
<p>Using array <code>index</code> as a key is <strong>problematic when the list can be reordered, filtered, or items are added/removed in the middle</strong>. Because:</p>
<ul>
<li>If you remove item at index 2, what was index 3 now becomes index 2. React thinks the element at index 2 is the same as before (same key), so it <strong>reuses the old DOM/state</strong> ‚Äî causing bugs.</li>
</ul>
<p><strong>Example of a bug:</strong>
If each list item has an <code>&lt;input&gt;</code>, and you delete an item from the middle, the input values can <strong>shift to wrong items</strong> because React associates state with keys.</p>
<p><strong>Best practice:</strong> Use a <strong>stable, unique identifier</strong> like a database <code>id</code>:</p>
<pre><code class="lang-jsx">{users.map(<span class="hljs-name">user</span> =&gt; (
  &lt;UserCard key={user.id} name={user.name} /&gt;
))}
</code></pre>
<p><strong>When is <code>index</code> okay?</strong></p>
<ul>
<li>The list is <strong>static</strong> (never reordered, filtered, or modified)</li>
<li>Items have <strong>no state</strong> (like simple text display)</li>
</ul>
<hr>
<p><strong>Q42: Can keys be same across different lists?</strong></p>
<p>Yes. Keys only need to be <strong>unique among siblings</strong> (within the same list). Two different lists can independently use the same key values. React uses keys for diffing <strong>within a specific parent</strong>, not globally.</p>
<hr>
<h2 id="fragments">FRAGMENTS</h2>
<p><strong>Q43: What are React Fragments? Why do we need them?</strong></p>
<p>Fragments let you <strong>group multiple elements</strong> without adding an extra DOM node. Since JSX requires a <strong>single root element</strong>, you&#39;d normally wrap elements in a <code>&lt;div&gt;</code>, which adds an unnecessary node to the DOM.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// ‚ùå Adds an unnecessary &lt;div&gt; to the DOM</span>
<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Description<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);

<span class="hljs-comment">// ‚úÖ Fragment ‚Äî no extra DOM node</span>
<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Description<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span>
);

// ‚úÖ Short syntax
return (
  <span class="hljs-tag">&lt;&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Description<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/&gt;</span>
);</span>
</code></pre>
<hr>
<p><strong>Q44: What is the difference between <code>&lt;React.Fragment&gt;</code> and <code>&lt;&gt;...&lt;/&gt;</code>?</strong></p>
<table>
<thead>
<tr>
<th><code>&lt;React.Fragment&gt;</code></th>
<th><code>&lt;&gt;...&lt;/&gt;</code> (Short syntax)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Supports the <strong><code>key</code></strong> attribute</td>
<td>Does <strong>not</strong> support <code>key</code> or any attributes</td>
</tr>
<tr>
<td>Required when rendering fragments <strong>inside a list</strong></td>
<td>Fine for simple grouping</td>
</tr>
</tbody>
</table>
<pre><code class="lang-jsx"><span class="hljs-comment">// Need keys? Must use React.Fragment</span>
{items.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>{item.term}<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>{item.description}<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span>
))}</span>
</code></pre>
<hr>
<h2 id="strictmode">STRICTMODE</h2>
<p><strong>Q45: What is <code>React.StrictMode</code>?</strong></p>
<p><code>StrictMode</code> is a <strong>development-only tool</strong> (it has <strong>no effect in production</strong>) that helps you find potential problems in your application. It wraps part (or all) of your component tree:</p>
<pre><code class="lang-jsx"><span class="hljs-section">&lt;React.StrictMode&gt;</span>
  <span class="hljs-section">&lt;App /&gt;</span>
<span class="hljs-section">&lt;/React.StrictMode&gt;</span>
</code></pre>
<hr>
<p><strong>Q46: What does StrictMode actually do?</strong></p>
<p>In development, StrictMode:</p>
<ol>
<li><strong>Double-invokes</strong> certain functions (component body, <code>useState</code> initializer, <code>useEffect</code> setup/cleanup, <code>useMemo</code>, <code>useReducer</code>) to help detect <strong>impure renders</strong> and <strong>side effects in the wrong places</strong></li>
<li>Warns about <strong>deprecated lifecycle methods</strong> (like <code>componentWillMount</code>)</li>
<li>Warns about <strong>legacy string refs</strong> and <strong>findDOMNode</strong> usage</li>
<li>Helps detect <strong>unexpected side effects</strong> ‚Äî if your component produces different results when called twice, you have an impurity</li>
</ol>
<hr>
<p><strong>Q47: Why does my component render twice in development?</strong></p>
<p>This is almost certainly because of <code>React.StrictMode</code>. It <strong>intentionally double-renders</strong> your components to help you identify impure logic and accidental side effects. This only happens in <strong>development mode</strong> ‚Äî in production, components render only once (per trigger).</p>
<p>If you remove <code>&lt;StrictMode&gt;</code> from your <code>index.js</code>/<code>main.jsx</code>, the double rendering stops. But it&#39;s <strong>recommended to keep it</strong> because it catches real bugs.</p>
<hr>
<p><strong>Q48: Does StrictMode affect performance in production?</strong></p>
<p><strong>No.</strong> StrictMode is completely stripped out in production builds. It adds zero runtime overhead to your production application. It&#39;s purely a <strong>development-time diagnostic tool</strong>.</p>
<hr>
<h2 id="bonus-rapid-fire-questions">BONUS RAPID-FIRE QUESTIONS</h2>
<p><strong>Q49: What is unidirectional data flow in React?</strong></p>
<p>Data flows in <strong>one direction</strong> ‚Äî from <strong>parent to child</strong> via props. A child cannot directly modify the parent&#39;s state. If a child needs to communicate back, the parent passes a <strong>callback function</strong> as a prop. This makes data flow predictable and debugging easier.</p>
<hr>
<p><strong>Q50: What is the difference between an Element and a Component?</strong></p>
<ul>
<li><p><strong>React Element</strong> ‚Äî A plain JavaScript object describing what you want on screen. It is <strong>immutable</strong> and cheap to create. It&#39;s what JSX produces: <code>&lt;h1&gt;Hello&lt;/h1&gt;</code> ‚Üí <code>{ type: &#39;h1&#39;, props: { children: &#39;Hello&#39; } }</code></p>
</li>
<li><p><strong>React Component</strong> ‚Äî A <strong>function or class</strong> that accepts props and returns React elements. Components are <strong>reusable</strong>, elements are not.</p>
</li>
</ul>
<pre><code class="lang-jsx"><span class="hljs-comment">// Element</span>
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;

<span class="hljs-comment">// Component</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}
</code></pre>
<hr>
<p><strong>Q51: What is a Pure Component?</strong></p>
<p>A pure component renders the <strong>same output for the same props and state</strong> ‚Äî no side effects. In class components, <code>React.PureComponent</code> implements <code>shouldComponentUpdate</code> with a <strong>shallow comparison</strong> of props and state. In functional components, wrapping with <code>React.memo</code> achieves similar behavior.</p>
<hr>
<p><strong>Q52: What happens if you call <code>setState</code> inside <code>render()</code> (class) or directly in the component body (functional)?</strong></p>
<p>It causes an <strong>infinite loop</strong>:</p>
<ul>
<li><code>setState</code> ‚Üí triggers re-render ‚Üí <code>render()</code> runs ‚Üí <code>setState</code> again ‚Üí re-render ‚Üí ... infinitely</li>
</ul>
<p>React will throw an error: <strong>&quot;Too many re-renders.&quot;</strong></p>
<p>State updates should be triggered by <strong>events</strong>, <strong>useEffect</strong>, or <strong>callbacks</strong> ‚Äî never unconditionally during render.</p>
<hr>
<h1 id="-hooks-interview-q-a">üîπ Hooks ‚Äî Interview Q&amp;A</h1>
<hr>
<h2 id="hooks-general-">HOOKS (General)</h2>
<p><strong>Q1: What are Hooks in React?</strong></p>
<p>Hooks are <strong>special functions</strong> introduced in <strong>React 16.8</strong> that let you <strong>use state, lifecycle features, and other React capabilities inside functional components</strong> ‚Äî without writing class components.</p>
<p>Before Hooks, if you needed state or lifecycle methods, you had to use class components. Hooks eliminated that limitation, making functional components the <strong>standard</strong> way to write React.</p>
<hr>
<p><strong>Q2: Why were Hooks introduced? What problems do they solve?</strong></p>
<p>Hooks solve three major problems that existed with class components:</p>
<ol>
<li><p><strong>Reusing stateful logic was hard</strong> ‚Äî Patterns like HOCs and Render Props worked but created &quot;wrapper hell&quot; (deeply nested component trees). Custom Hooks allow sharing logic <strong>without changing the component hierarchy</strong>.</p>
</li>
<li><p><strong>Complex components became hard to understand</strong> ‚Äî In class components, related logic was split across multiple lifecycle methods (<code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>). Unrelated logic was forced into the same method. Hooks let you <strong>split logic by concern</strong>, not by lifecycle.</p>
</li>
<li><p><strong>Classes are confusing</strong> ‚Äî The <code>this</code> keyword, binding event handlers, and understanding when to use arrow functions confused many developers. Hooks let you use <strong>plain functions</strong> ‚Äî no <code>this</code>, no binding.</p>
</li>
</ol>
<hr>
<h2 id="usestate">useState</h2>
<p><strong>Q3: What is <code>useState</code>? How does it work?</strong></p>
<p><code>useState</code> is a Hook that lets you <strong>add state to functional components</strong>. It returns an <strong>array with two elements</strong>:</p>
<ol>
<li>The <strong>current state value</strong></li>
<li>A <strong>setter function</strong> to update that state</li>
</ol>
<pre><code class="lang-jsx">const [count, <span class="hljs-built_in">set</span>Count] = useState(<span class="hljs-number">0</span>);
//      ^         ^                ^
//  <span class="hljs-keyword">state</span> var   setter       initial value
</code></pre>
<p>When the setter is called, React <strong>re-renders</strong> the component with the updated value.</p>
<hr>
<p><strong>Q4: Can you use <code>useState</code> multiple times in one component?</strong></p>
<p>Yes. You can call <code>useState</code> as many times as you need for different pieces of state:</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserForm</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> [age, setAge] = useState(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> [isActive, setIsActive] = useState(<span class="hljs-literal">true</span>);

  <span class="hljs-comment">// Each has its own independent state variable and setter</span>
}
</code></pre>
<p>This is actually <strong>preferred</strong> over putting everything in a single state object, because each piece of state updates independently without needing to spread the rest.</p>
<hr>
<p><strong>Q5: What is lazy initialization in <code>useState</code>?</strong></p>
<p>If the initial state requires an <strong>expensive computation</strong>, you can pass a <strong>function</strong> to <code>useState</code> instead of a value. This function runs <strong>only on the first render</strong>, not on every re-render:</p>
<pre><code class="lang-jsx">// ‚ùå Expensive <span class="hljs-function"><span class="hljs-keyword">function</span></span> runs on EVERY render
const [<span class="hljs-keyword">data</span>, setData] = useState(expensiveComputation());

// ‚úÖ Expensive <span class="hljs-function"><span class="hljs-keyword">function</span></span> runs <span class="hljs-keyword">only</span> on FIRST render
const [<span class="hljs-keyword">data</span>, setData] = useState(() =&gt; expensiveComputation());
</code></pre>
<p>Common use cases: reading from <code>localStorage</code>, parsing large data, heavy calculations.</p>
<hr>
<p><strong>Q6: How do you update state that depends on the previous state?</strong></p>
<p>Use the <strong>functional updater form</strong> ‚Äî pass a function to the setter that receives the previous state:</p>
<pre><code class="lang-jsx">// ‚ùå May cause bugs due <span class="hljs-keyword">to</span> stale <span class="hljs-keyword">state</span> (batching)
<span class="hljs-built_in">set</span>Count(count + <span class="hljs-number">1</span>);
<span class="hljs-built_in">set</span>Count(count + <span class="hljs-number">1</span>); // Both read same stale 'count'

// ‚úÖ Always uses the latest previous <span class="hljs-keyword">state</span>
<span class="hljs-built_in">set</span>Count(prev =&gt; prev + <span class="hljs-number">1</span>);
<span class="hljs-built_in">set</span>Count(prev =&gt; prev + <span class="hljs-number">1</span>); // Correctly increments twice
</code></pre>
<p><strong>Rule of thumb:</strong> Whenever the new state depends on the old state, use the functional form.</p>
<hr>
<p><strong>Q7: How do you update objects or arrays in state with <code>useState</code>?</strong></p>
<p><code>useState</code> <strong>replaces</strong> state entirely (unlike <code>this.setState</code> which shallow merges). So you must <strong>spread the previous state</strong> when updating objects or arrays:</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Object</span>
<span class="hljs-keyword">const</span> [user, setUser] = useState({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Rahul'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> });

<span class="hljs-comment">// ‚ùå Loses 'name'</span>
setUser({ <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> });

<span class="hljs-comment">// ‚úÖ Spread previous state</span>
setUser(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> ({ ...prev, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> }));


<span class="hljs-comment">// Array ‚Äî adding an item</span>
<span class="hljs-keyword">const</span> [items, setItems] = useState([<span class="hljs-string">'Apple'</span>, <span class="hljs-string">'Banana'</span>]);

<span class="hljs-comment">// ‚úÖ Spread previous array</span>
setItems(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, <span class="hljs-string">'Cherry'</span>]);

<span class="hljs-comment">// Array ‚Äî removing an item</span>
setItems(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item !== <span class="hljs-string">'Banana'</span>));

<span class="hljs-comment">// Array ‚Äî updating an item</span>
setItems(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>
  item === <span class="hljs-string">'Apple'</span> ? <span class="hljs-string">'Green Apple'</span> : item
));
</code></pre>
<p><strong>Never mutate state directly</strong> ‚Äî always create a <strong>new reference</strong> (new object/array).</p>
<hr>
<p><strong>Q8: Why does React not re-render when you mutate state directly?</strong></p>
<p>React uses <strong>reference comparison</strong> (Object.is) to determine if state changed. If you mutate an object/array directly, the <strong>reference stays the same</strong>, so React thinks nothing changed and <strong>skips the re-render</strong>:</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// ‚ùå Same reference ‚Äî React won't re-render</span>
<span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  user.age = <span class="hljs-number">26</span>;      <span class="hljs-comment">// Mutation!</span>
  setUser(user);       <span class="hljs-comment">// Same reference, React ignores it</span>
};

<span class="hljs-comment">// ‚úÖ New reference ‚Äî React detects the change</span>
<span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  setUser({ ...user, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> }); <span class="hljs-comment">// New object</span>
};
</code></pre>
<hr>
<h2 id="useeffect">useEffect</h2>
<p><strong>Q9: What is <code>useEffect</code>? Why do we need it?</strong></p>
<p><code>useEffect</code> is a Hook that lets you perform <strong>side effects</strong> in functional components. Side effects are operations that interact with the <strong>outside world</strong> or happen <strong>outside React&#39;s rendering process</strong>:</p>
<ul>
<li>Fetching data from an API</li>
<li>Setting up subscriptions or event listeners</li>
<li>Manually changing the DOM</li>
<li>Timers (<code>setTimeout</code>, <code>setInterval</code>)</li>
<li>Logging</li>
</ul>
<pre><code class="lang-jsx">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-regexp">//</span> Side effect logic here
}, [dependencies]);
</code></pre>
<p>It replaces <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> from class components ‚Äî all in one API.</p>
<hr>
<p><strong>Q10: Explain the different behaviors of <code>useEffect</code> based on the dependency array.</strong></p>
<pre><code class="lang-jsx">// 1. No dependency<span class="hljs-built_in"> array </span>‚Äî runs after EVERY render
useEffect(() =&gt; {
  console.log('Runs after every render');
});

// 2. Empty<span class="hljs-built_in"> array </span>‚Äî runs ONLY once after the first render (mount)
useEffect(() =&gt; {
  console.log('Runs only on mount');
}, []);

// 3. With dependencies ‚Äî runs on mount + whenever any dependency changes
useEffect(() =&gt; {
  console.log('Runs when count<span class="hljs-built_in"> or </span>name changes');
}, [count, name]);
</code></pre>
<table>
<thead>
<tr>
<th>Dependency Array</th>
<th>When it Runs</th>
</tr>
</thead>
<tbody>
<tr>
<td>Not provided</td>
<td>After <strong>every</strong> render</td>
</tr>
<tr>
<td><code>[]</code> (empty)</td>
<td><strong>Once</strong> after first render (mount)</td>
</tr>
<tr>
<td><code>[a, b]</code></td>
<td>After mount + whenever <code>a</code> or <code>b</code> changes</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Q11: Can you have multiple <code>useEffect</code> in one component?</strong></p>
<p>Yes, and it is <strong>encouraged</strong>. Separate unrelated side effects into different <code>useEffect</code> calls for better readability and maintainability:</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserProfile</span>(<span class="hljs-params">{ userId }</span>) </span>{
  <span class="hljs-comment">// Effect 1: Fetch user data</span>
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    fetchUser(userId);
  }, [userId]);

  <span class="hljs-comment">// Effect 2: Update document title</span>
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">'User Profile'</span>;
  }, []);

  <span class="hljs-comment">// Effect 3: Set up WebSocket</span>
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> WebSocket(url);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ws.close();
  }, []);
}
</code></pre>
<p>This is one of the advantages over class components where unrelated logic was crammed into a single <code>componentDidMount</code>.</p>
<hr>
<p><strong>Q12: What happens if you don&#39;t provide a dependency array to <code>useEffect</code>?</strong></p>
<p>The effect runs <strong>after every single render</strong> ‚Äî initial render and every subsequent re-render. This is usually <strong>not what you want</strong> and can cause performance problems or even infinite loops (if the effect itself triggers a state update).</p>
<pre><code class="lang-jsx"><span class="hljs-regexp">//</span> ‚ö†Ô∏è Runs after EVERY render
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'I run on every render'</span>);
});
</code></pre>
<hr>
<p><strong>Q13: What is a common mistake that causes infinite loops with <code>useEffect</code>?</strong></p>
<p>Updating state inside <code>useEffect</code> <strong>without proper dependencies</strong>:</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// ‚ùå INFINITE LOOP</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  setCount(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// State update ‚Üí re-render ‚Üí effect runs ‚Üí state update ‚Üí ...</span>
});

<span class="hljs-comment">// ‚ùå INFINITE LOOP ‚Äî object/array as dependency</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  fetchData();
}, [{ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> }]); <span class="hljs-comment">// New object reference on every render ‚Üí effect runs every time</span>
</code></pre>
<p><strong>Fixes:</strong></p>
<ul>
<li>Add proper dependencies</li>
<li>Use the functional updater: <code>setCount(prev =&gt; prev + 1)</code></li>
<li>Memoize objects/arrays used as dependencies</li>
<li>Add conditions inside the effect</li>
</ul>
<hr>
<p><strong>Q14: Can <code>useEffect</code> be async?</strong></p>
<p>The <strong>effect function itself cannot be async</strong> because <code>useEffect</code> expects either <code>undefined</code> or a <strong>cleanup function</strong> as the return value ‚Äî not a <code>Promise</code>.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// ‚ùå WRONG ‚Äî returns a Promise</span>
useEffect(<span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetchData();
}, []);

<span class="hljs-comment">// ‚úÖ CORRECT ‚Äî define async function inside</span>
useEffect(() =&gt; {
  <span class="hljs-keyword">const</span> getData = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetchData();
    setData(data);
  };

  getData();
}, []);
</code></pre>
<hr>
<h2 id="cleanup-function">CLEANUP FUNCTION</h2>
<p><strong>Q15: What is the cleanup function in <code>useEffect</code>?</strong></p>
<p>The cleanup function is a function <strong>returned</strong> from <code>useEffect</code>. React calls it to <strong>clean up the previous effect</strong> before running the effect again, and also when the component <strong>unmounts</strong>.</p>
<pre><code class="lang-jsx">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// Setup</span>
  <span class="hljs-keyword">const</span> subscription = subscribeToData(userId);

  <span class="hljs-comment">// Cleanup ‚Äî returned function</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    subscription.unsubscribe();
  };
}, [userId]);
</code></pre>
<hr>
<p><strong>Q16: When does the cleanup function run?</strong></p>
<p>Two scenarios:</p>
<ol>
<li><strong>Before the effect re-runs</strong> ‚Äî When dependencies change, React first runs the cleanup of the <strong>previous</strong> effect, then runs the new effect</li>
<li><strong>When the component unmounts</strong> ‚Äî React runs cleanup one final time</li>
</ol>
<p><strong>Timeline example with <code>[userId]</code> dependency:</strong></p>
<pre><code>Mount (userId = <span class="hljs-number">1</span>):
  ‚Üí Setup effect (subscribe to <span class="hljs-keyword">user</span> <span class="hljs-title">1</span>)

userId changes to <span class="hljs-number">2</span>:
  ‚Üí Cleanup previous effect (unsubscribe from <span class="hljs-keyword">user</span> <span class="hljs-title">1</span>)
  ‚Üí Setup effect (subscribe to <span class="hljs-keyword">user</span> <span class="hljs-title">2</span>)

Unmount:
  ‚Üí Cleanup (unsubscribe from <span class="hljs-keyword">user</span> <span class="hljs-title">2</span>)
</code></pre><hr>
<p><strong>Q17: Give real-world examples where cleanup is essential.</strong></p>
<pre><code class="lang-jsx"><span class="hljs-comment">// 1. Event Listeners</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> handleResize = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setWidth(<span class="hljs-built_in">window</span>.innerWidth);
  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, handleResize);

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'resize'</span>, handleResize);
}, []);

<span class="hljs-comment">// 2. Timers</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setSeconds(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
  }, <span class="hljs-number">1000</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> clearInterval(interval);
}, []);

<span class="hljs-comment">// 3. WebSocket</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">'wss://example.com'</span>);
  ws.onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> setMessages(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, event.data]);

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ws.close();
}, []);
</code></pre>
<p><strong>Without cleanup:</strong> You&#39;d have <strong>memory leaks</strong>, stale event listeners stacking up, and timers running even after the component is gone.</p>
<hr>
<p><strong>Q18: What happens if you forget to clean up?</strong></p>
<ul>
<li><strong>Memory leaks</strong> ‚Äî subscriptions, listeners, and timers keep running in the background</li>
<li><strong>Stale updates</strong> ‚Äî trying to update state on an <strong>unmounted</strong> component (React will warn: &quot;Can&#39;t perform a React state update on an unmounted component&quot;)</li>
<li><strong>Multiple listeners</strong> ‚Äî event handlers pile up on each re-render, causing duplicated behavior</li>
<li><strong>Unexpected behavior</strong> ‚Äî old WebSocket connections or intervals interfere with new ones</li>
</ul>
<hr>
<h2 id="usecontext">useContext</h2>
<p><strong>Q19: What is <code>useContext</code>?</strong></p>
<p><code>useContext</code> is a Hook that lets you <strong>consume</strong> a React Context value directly in a functional component, without needing the <code>&lt;Context.Consumer&gt;</code> wrapper pattern.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// 1. Create Context</span>
<span class="hljs-keyword">const</span> ThemeContext = React.createContext(<span class="hljs-string">'light'</span>);

<span class="hljs-comment">// 2. Provide value (in a parent)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> (
    &lt;ThemeContext.Provider value=<span class="hljs-string">"dark"</span>&gt;
      &lt;Toolbar /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

<span class="hljs-comment">// 3. Consume value (in any deeply nested child)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ThemedButton</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">const</span> theme = useContext(ThemeContext);
  <span class="hljs-keyword">return</span> &lt;button className={theme}&gt;Click me&lt;/button&gt;;
}
</code></pre>
<hr>
<p><strong>Q20: What problem does <code>useContext</code> solve?</strong></p>
<p>It solves <strong>props drilling</strong> ‚Äî the problem where you pass props through many intermediate components that don&#39;t actually need them, just to get data to a deeply nested child.</p>
<pre><code>Without <span class="hljs-keyword">Context</span> (props drilling):
App ‚Üí Layout ‚Üí Sidebar ‚Üí <span class="hljs-keyword">Menu</span> ‚Üí <span class="hljs-keyword">MenuItem</span> (needs theme)
  theme={theme} passed through EVERY level

<span class="hljs-keyword">With</span> <span class="hljs-keyword">Context</span>:
App (Provider) ‚Üí ... ‚Üí <span class="hljs-keyword">MenuItem</span> (useContext) ‚Äî skips all intermediaries
</code></pre><hr>
<p><strong>Q21: Does every component that uses <code>useContext</code> re-render when the context value changes?</strong></p>
<p><strong>Yes.</strong> Every component that calls <code>useContext(SomeContext)</code> will re-render whenever the <strong>Provider&#39;s value changes</strong> ‚Äî even if the specific part of the context the component uses didn&#39;t change.</p>
<p>This is a <strong>known limitation</strong> and can cause performance issues. Solutions include:</p>
<ul>
<li><strong>Splitting contexts</strong> ‚Äî separate frequently changing values into their own contexts</li>
<li><strong>Memoizing the context value</strong> in the Provider</li>
<li>Using state management libraries like <strong>Redux</strong> or <strong>Zustand</strong> for complex cases</li>
</ul>
<pre><code class="lang-jsx">// ‚ùå Every consumer re-renders <span class="hljs-keyword">when</span> ANY <span class="hljs-keyword">value</span> changes
&lt;AppContext.Provider <span class="hljs-keyword">value</span>={{ user, theme, language }}&gt;

// ‚úÖ Split into separate contexts
&lt;UserContext.Provider <span class="hljs-keyword">value</span>={user}&gt;
  &lt;ThemeContext.Provider <span class="hljs-keyword">value</span>={theme}&gt;
</code></pre>
<hr>
<h2 id="useref">useRef</h2>
<p><strong>Q22: What is <code>useRef</code>?</strong></p>
<p><code>useRef</code> is a Hook that returns a <strong>mutable ref object</strong> with a <code>.current</code> property. It has two primary uses:</p>
<ol>
<li><strong>Accessing DOM elements</strong> directly</li>
<li><strong>Storing mutable values</strong> that persist across renders but <strong>don&#39;t trigger re-renders</strong> when changed</li>
</ol>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> myRef = useRef(initialValue);
<span class="hljs-comment">// myRef.current = initialValue</span>
</code></pre>
<hr>
<p><strong>Q23: How is <code>useRef</code> used to access DOM elements?</strong></p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TextInput</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> inputRef = useRef(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> focusInput = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    inputRef.current.focus(); <span class="hljs-comment">// Directly access the DOM node</span>
  };

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;input ref={inputRef} type="text" /&gt;
      &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>When you attach <code>ref={inputRef}</code> to a JSX element, React sets <code>inputRef.current</code> to the <strong>actual DOM node</strong> after mounting.</p>
<hr>
<p><strong>Q24: How is <code>useRef</code> different from <code>useState</code>?</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>useRef</code></th>
<th><code>useState</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Triggers re-render on change</td>
<td><strong>No</strong></td>
<td><strong>Yes</strong></td>
</tr>
<tr>
<td>Returns</td>
<td><code>{ current: value }</code> object</td>
<td><code>[value, setter]</code> array</td>
</tr>
<tr>
<td>Persists across renders</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>When to use</td>
<td>DOM access, storing values that shouldn&#39;t cause re-render</td>
<td>Values that should reflect in the UI</td>
</tr>
</tbody>
</table>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Timer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [seconds, setSeconds] = useState(<span class="hljs-number">0</span>);  <span class="hljs-comment">// Shown in UI ‚Üí useState</span>
  <span class="hljs-keyword">const</span> intervalRef = useRef(<span class="hljs-literal">null</span>);            <span class="hljs-comment">// Internal reference ‚Üí useRef</span>

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    intervalRef.current = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      setSeconds(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> clearInterval(intervalRef.current);
  }, []);

  <span class="hljs-keyword">const</span> stop = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> clearInterval(intervalRef.current);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{seconds}s <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{stop}</span>&gt;</span>Stop<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}
</code></pre>
<p>Here, <code>intervalRef</code> stores the interval ID ‚Äî we need it to persist across renders, but changing it shouldn&#39;t trigger a re-render.</p>
<hr>
<p><strong>Q25: Can <code>useRef</code> be used to store the previous value of state?</strong></p>
<p>Yes, this is a classic pattern:</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> prevCountRef = useRef();

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    prevCountRef.current = count; <span class="hljs-comment">// Runs AFTER render, stores previous value</span>
  }, [count]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      Current: {count}, Previous: {prevCountRef.current}
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
  );
}
</code></pre>
<p>Since <code>useRef</code> doesn&#39;t trigger re-renders, and <code>useEffect</code> runs <strong>after</strong> render, <code>prevCountRef.current</code> always holds the value from the <strong>previous render</strong>.</p>
<hr>
<p><strong>Q26: Why doesn&#39;t changing <code>useRef.current</code> cause a re-render?</strong></p>
<p>Because <code>useRef</code> returns the <strong>same object reference</strong> on every render. React doesn&#39;t track changes to <code>.current</code> ‚Äî it&#39;s just a plain JavaScript object property. React only re-renders when <code>setState</code>/<code>useState</code> setter is called, context changes, or the parent re-renders. Mutating a ref is <strong>invisible</strong> to React&#39;s rendering system.</p>
<hr>
<h2 id="usereducer">useReducer</h2>
<p><strong>Q27: What is <code>useReducer</code>?</strong></p>
<p><code>useReducer</code> is a Hook for managing <strong>complex state logic</strong>. It is an alternative to <code>useState</code> and works similarly to <strong>Redux</strong> ‚Äî you dispatch <strong>actions</strong> to a <strong>reducer function</strong> that determines how state should change.</p>
<pre><code class="lang-jsx">const [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialState);
</code></pre>
<hr>
<p><strong>Q28: When should you use <code>useReducer</code> over <code>useState</code>?</strong></p>
<table>
<thead>
<tr>
<th>Use <code>useState</code></th>
<th>Use <code>useReducer</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Simple state (string, number, boolean)</td>
<td>Complex state objects with multiple sub-values</td>
</tr>
<tr>
<td>Few state transitions</td>
<td>Multiple related state transitions</td>
</tr>
<tr>
<td>Independent state updates</td>
<td>Next state depends on previous state in complex ways</td>
</tr>
<tr>
<td>Simple components</td>
<td>State logic needs to be shared or tested separately</td>
</tr>
</tbody>
</table>
<p><strong>Rule of thumb:</strong> If you find yourself with multiple related <code>useState</code> calls where updates depend on each other, switch to <code>useReducer</code>.</p>
<hr>
<p><strong>Q29: Give a practical example of <code>useReducer</code>.</strong></p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'increment'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.count + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'decrement'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.count - <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'reset'</span>:
      <span class="hljs-keyword">return</span> initialState;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'set'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: action.payload };
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unknown action: '</span> + action.type);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'increment' })}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'decrement' })}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'reset' })}&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'set', payload: 100 })}&gt;Set 100<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>The <strong>reducer is a pure function</strong> ‚Äî given the same state and action, it always returns the same new state. All state transition logic is centralized in one place.</p>
<hr>
<p><strong>Q30: What are the advantages of <code>useReducer</code>?</strong></p>
<ol>
<li><strong>Centralized state logic</strong> ‚Äî all transitions in one function, easy to read and debug</li>
<li><strong>Predictable</strong> ‚Äî reducer is a pure function, easy to test in isolation</li>
<li><strong>Scalable</strong> ‚Äî handles complex state better than multiple <code>useState</code> calls</li>
<li><strong>Action-based updates</strong> ‚Äî descriptive action types make it clear <em>what happened</em></li>
<li><strong>Pairs well with <code>useContext</code></strong> ‚Äî passing <code>dispatch</code> via context is a lightweight Redux alternative</li>
</ol>
<hr>
<h2 id="usememo">useMemo</h2>
<p><strong>Q31: What is <code>useMemo</code>?</strong></p>
<p><code>useMemo</code> is a Hook that <strong>memoizes the result of an expensive computation</strong> and returns the <strong>cached value</strong> unless its dependencies change. It prevents unnecessary recalculations on every render.</p>
<pre><code class="lang-jsx">const memoizedValue = useMemo(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> expensiveCalculation(a, b);
}, [a, b]);
</code></pre>
<ul>
<li>The function runs on mount and only re-runs when <code>a</code> or <code>b</code> changes</li>
<li>On all other re-renders, it returns the <strong>previously cached result</strong></li>
</ul>
<hr>
<p><strong>Q32: Give a practical example where <code>useMemo</code> is useful.</strong></p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProductList</span>(<span class="hljs-params">{ products, searchTerm }</span>) </span>{
  <span class="hljs-comment">// ‚ùå Without useMemo ‚Äî filters on EVERY render (even when products/searchTerm haven't changed)</span>
  <span class="hljs-keyword">const</span> filtered = products.filter(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span>
    p.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  <span class="hljs-comment">// ‚úÖ With useMemo ‚Äî only recalculates when products or searchTerm changes</span>
  <span class="hljs-keyword">const</span> filtered = useMemo(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> products.filter(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span>
      p.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [products, searchTerm]);

  <span class="hljs-keyword">return</span> filtered.map(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &lt;ProductCard key={p.id} product={p} /&gt;);
}
</code></pre>
<p>If the parent re-renders for an unrelated reason (like a different state change), the filtering won&#39;t re-run unnecessarily.</p>
<hr>
<p><strong>Q33: Should you wrap everything in <code>useMemo</code>?</strong></p>
<p><strong>No.</strong> <code>useMemo</code> itself has a cost ‚Äî it stores previous values in memory and compares dependencies on every render. For simple calculations, the overhead of memoization can be <strong>greater</strong> than just recalculating.</p>
<p><strong>Use <code>useMemo</code> when:</strong></p>
<ul>
<li>The computation is genuinely <strong>expensive</strong> (large list filtering, complex math, etc.)</li>
<li>You need <strong>referential equality</strong> ‚Äî preserving the same object/array reference to prevent child re-renders</li>
<li>Profiling confirms there&#39;s a performance problem</li>
</ul>
<p><strong>Don&#39;t use it for:</strong> simple arithmetic, string concatenation, or trivial operations.</p>
<hr>
<h2 id="usecallback">useCallback</h2>
<p><strong>Q34: What is <code>useCallback</code>?</strong></p>
<p><code>useCallback</code> is a Hook that <strong>memoizes a function definition</strong> so that the same function reference is returned across re-renders, unless its dependencies change.</p>
<pre><code class="lang-jsx">const memoizedFn = useCallback(() =&gt; {
  doSomething(<span class="hljs-name">a</span>, b)<span class="hljs-comment">;</span>
}, [a, b])<span class="hljs-comment">;</span>
</code></pre>
<hr>
<p><strong>Q35: What is the difference between <code>useMemo</code> and <code>useCallback</code>?</strong></p>
<table>
<thead>
<tr>
<th><code>useMemo</code></th>
<th><code>useCallback</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Memoizes a <strong>computed value</strong> (result)</td>
<td>Memoizes a <strong>function reference</strong></td>
</tr>
<tr>
<td>Returns the <strong>return value</strong> of the function</td>
<td>Returns the <strong>function itself</strong></td>
</tr>
<tr>
<td><code>useMemo(() =&gt; fn(a), [a])</code></td>
<td><code>useCallback((x) =&gt; fn(x, a), [a])</code></td>
</tr>
</tbody>
</table>
<p>They are essentially the same under the hood:</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// These are equivalent:</span>
<span class="hljs-function"><span class="hljs-title">useCallback</span><span class="hljs-params">(fn, deps)</span></span>
<span class="hljs-function"><span class="hljs-title">useMemo</span><span class="hljs-params">(()</span></span> =&gt; fn, deps)
</code></pre>
<hr>
<p><strong>Q36: When is <code>useCallback</code> actually useful?</strong></p>
<p><code>useCallback</code> is primarily useful when passing callbacks to <strong>optimized child components</strong> that use <code>React.memo</code>:</p>
<pre><code class="lang-jsx">const Parent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  const [count, setCount] = useState(<span class="hljs-number">0</span>);
  const [text, setText] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-regexp">//</span> ‚ùå Without useCallback ‚Äî <span class="hljs-keyword">new</span> function reference <span class="hljs-literal">on</span> every render
  <span class="hljs-regexp">//</span> Child re-renders even <span class="hljs-keyword">when</span> only <span class="hljs-string">'text'</span> changed
  const handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setCount(prev =&gt; prev + <span class="hljs-number">1</span>);

  <span class="hljs-regexp">//</span> ‚úÖ With useCallback ‚Äî same reference <span class="hljs-keyword">unless</span> dependencies change
  const handleClick = useCallback(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setCount(prev =&gt; prev + <span class="hljs-number">1</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;input value={text} onChange={e =&gt; setText(e.target.value)} /&gt;
      &lt;ExpensiveChild onClick={handleClick} /&gt;
    &lt;/&gt;
  );
};

const ExpensiveChild = React.memo(<span class="hljs-function"><span class="hljs-params">({ onClick })</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Child rendered'</span>);
  <span class="hljs-keyword">return</span> &lt;button onClick={onClick}&gt;Click&lt;/button&gt;;
});
</code></pre>
<p>Without <code>useCallback</code>, typing in the input re-renders <code>Parent</code>, creating a <strong>new <code>handleClick</code> reference</strong>, which defeats <code>React.memo</code> and re-renders <code>ExpensiveChild</code> unnecessarily.</p>
<p><strong>Key insight:</strong> <code>useCallback</code> is <strong>pointless</strong> if the child is <strong>not</strong> memoized with <code>React.memo</code>. Without <code>React.memo</code>, the child re-renders anyway because its parent re-rendered.</p>
<hr>
<h2 id="useref-vs-usememo-vs-usecallback-comparison-">useRef vs useMemo vs useCallback (Comparison)</h2>
<p><strong>Q37: Quick comparison ‚Äî when to use what?</strong></p>
<table>
<thead>
<tr>
<th>Hook</th>
<th>Purpose</th>
<th>Triggers Re-render?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>useRef</code></td>
<td>Store mutable value or DOM reference</td>
<td><strong>No</strong></td>
</tr>
<tr>
<td><code>useMemo</code></td>
<td>Cache expensive <strong>computed value</strong></td>
<td><strong>No</strong> (prevents recomputation)</td>
</tr>
<tr>
<td><code>useCallback</code></td>
<td>Cache <strong>function reference</strong></td>
<td><strong>No</strong> (prevents function recreation)</td>
</tr>
<tr>
<td><code>useState</code></td>
<td>Store reactive state</td>
<td><strong>Yes</strong></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="custom-hooks">Custom Hooks</h2>
<p><strong>Q38: What are custom Hooks?</strong></p>
<p>Custom Hooks are <strong>regular JavaScript functions</strong> whose names start with <code>use</code> and that can call other Hooks. They let you <strong>extract and reuse stateful logic</strong> across multiple components without duplicating code or changing the component hierarchy.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Custom Hook</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useWindowWidth</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [width, setWidth] = useState(<span class="hljs-built_in">window</span>.innerWidth);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> handleResize = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setWidth(<span class="hljs-built_in">window</span>.innerWidth);
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, handleResize);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'resize'</span>, handleResize);
  }, []);

  <span class="hljs-keyword">return</span> width;
}

<span class="hljs-comment">// Usage in any component</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Navbar</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> width = useWindowWidth();
  <span class="hljs-keyword">return</span> width &gt; <span class="hljs-number">768</span> ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">DesktopNav</span> /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">MobileNav</span> /&gt;</span>;
}

function Sidebar() {
  const width = useWindowWidth();
  if (width <span class="hljs-tag">&lt; <span class="hljs-attr">768</span>) <span class="hljs-attr">return</span> <span class="hljs-attr">null</span>;
  <span class="hljs-attr">return</span> &lt;<span class="hljs-attr">aside</span>&gt;</span>Sidebar content<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>;
}</span>
</code></pre>
<p>Both components <strong>share the logic</strong> but have their <strong>own independent state</strong> ‚Äî custom Hooks share logic, not state.</p>
<hr>
<p><strong>Q39: Do custom Hooks share state between components that use them?</strong></p>
<p><strong>No.</strong> Each component that calls a custom Hook gets its <strong>own isolated copy</strong> of the state inside that Hook. Custom Hooks share <strong>logic</strong> (the code), not <strong>state</strong> (the data).</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ComponentA</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">const</span> width = useWindowWidth(); <span class="hljs-comment">// Own independent width state</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ComponentB</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">const</span> width = useWindowWidth(); <span class="hljs-comment">// Completely separate width state</span>
}
</code></pre>
<hr>
<p><strong>Q40: Give examples of common custom Hooks you might build.</strong></p>
<pre><code class="lang-jsx"><span class="hljs-comment">// 1. useLocalStorage ‚Äî persist state in localStorage</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useLocalStorage</span>(<span class="hljs-params">key, initialValue</span>) </span>{
  <span class="hljs-keyword">const</span> [value, setValue] = useState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> stored = localStorage.getItem(key);
    <span class="hljs-keyword">return</span> stored ? <span class="hljs-built_in">JSON</span>.parse(stored) : initialValue;
  });

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    localStorage.setItem(key, <span class="hljs-built_in">JSON</span>.stringify(value));
  }, [key, value]);

  <span class="hljs-keyword">return</span> [value, setValue];
}

<span class="hljs-comment">// 2. useFetch ‚Äî reusable data fetching</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFetch</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">const</span> [data, setData] = useState(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [loading, setLoading] = useState(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">const</span> [error, setError] = useState(<span class="hljs-literal">null</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> fetchData = <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">try</span> {
        setLoading(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(url);
        <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> res.json();
        setData(json);
      } <span class="hljs-keyword">catch</span> (err) {
        setError(err);
      } <span class="hljs-keyword">finally</span> {
        setLoading(<span class="hljs-literal">false</span>);
      }
    };
    fetchData();
  }, [url]);

  <span class="hljs-keyword">return</span> { data, loading, error };
}

<span class="hljs-comment">// 3. useDebounce ‚Äî debounce a value</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useDebounce</span>(<span class="hljs-params">value, delay</span>) </span>{
  <span class="hljs-keyword">const</span> [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setDebouncedValue(value), delay);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> clearTimeout(timer);
  }, [value, delay]);

  <span class="hljs-keyword">return</span> debouncedValue;
}
</code></pre>
<hr>
<p><strong>Q41: What are the naming conventions for custom Hooks?</strong></p>
<ul>
<li>The name <strong>must start with <code>use</code></strong> ‚Äî e.g., <code>useAuth</code>, <code>useFetch</code>, <code>useForm</code></li>
<li>This is not just a convention ‚Äî React&#39;s <strong>linter plugin</strong> uses the <code>use</code> prefix to enforce the Rules of Hooks</li>
<li>Without the <code>use</code> prefix, React can&#39;t tell if a function contains Hook calls, so it can&#39;t check for rule violations</li>
</ul>
<hr>
<h2 id="rules-of-hooks">Rules of Hooks</h2>
<p><strong>Q42: What are the Rules of Hooks?</strong></p>
<p>Two critical rules:</p>
<p><strong>Rule 1: Only call Hooks at the top level</strong></p>
<ul>
<li>Do <strong>NOT</strong> call Hooks inside loops, conditions, or nested functions</li>
<li>Hooks must be called in the <strong>same order</strong> on every render</li>
</ul>
<pre><code class="lang-jsx"><span class="hljs-comment">// ‚ùå WRONG ‚Äî conditional Hook</span>
<span class="hljs-keyword">if</span> (isLoggedIn) {
  <span class="hljs-keyword">const</span> [user, setUser] = useState(<span class="hljs-literal">null</span>); <span class="hljs-comment">// Breaks Hook order</span>
}

<span class="hljs-comment">// ‚ùå WRONG ‚Äî Hook inside loop</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}); <span class="hljs-comment">// Breaks Hook order</span>
}

<span class="hljs-comment">// ‚úÖ CORRECT ‚Äî condition INSIDE the Hook</span>
<span class="hljs-keyword">const</span> [user, setUser] = useState(<span class="hljs-literal">null</span>);
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (isLoggedIn) {
    fetchUser().then(setUser);
  }
}, [isLoggedIn]);
</code></pre>
<p><strong>Rule 2: Only call Hooks from React functions</strong></p>
<ul>
<li>Call Hooks from <strong>functional components</strong> or <strong>custom Hooks</strong></li>
<li>Do <strong>NOT</strong> call Hooks from regular JavaScript functions, class components, or event handlers</li>
</ul>
<hr>
<p><strong>Q43: Why must Hooks be called in the same order every render?</strong></p>
<p>React <strong>doesn&#39;t use names</strong> to track Hooks ‚Äî it uses <strong>call order</strong> (an internal list/array). On each render, React matches Hooks by their <strong>position</strong> in the sequence:</p>
<pre><code>Render <span class="hljs-number">1</span>:          Render 2:
useState (1st)     useState (1st)      ‚úÖ matched
useEffect (2nd)    useEffect (2nd)     ‚úÖ matched
useState (3rd)     useState (3rd)      ‚úÖ matched
</code></pre><p>If you skip a Hook conditionally:</p>
<pre><code>Render <span class="hljs-number">1</span>:          Render 2 (condition <span class="hljs-keyword">false</span>):
useState (1st)     useState (1st)       ‚úÖ
useEffect (2nd)    ‚Äî skipped ‚Äî
useState (3rd)     useState (2nd)       ‚ùå MISMATCH! Gets wrong state
</code></pre><p>This is why conditional/loop Hooks break the app ‚Äî React pairs Hook #2 with the wrong state, causing unpredictable bugs.</p>
<hr>
<p><strong>Q44: What tool helps enforce the Rules of Hooks?</strong></p>
<p>The <strong><code>eslint-plugin-react-hooks</code></strong> ESLint plugin. It has two rules:</p>
<ol>
<li><strong><code>rules-of-hooks</code></strong> ‚Äî ensures Hooks are called at the top level and only from React functions</li>
<li><strong><code>exhaustive-deps</code></strong> ‚Äî warns when <code>useEffect</code>/<code>useMemo</code>/<code>useCallback</code> dependencies are missing or incorrect</li>
</ol>
<p>This plugin is <strong>included by default</strong> in Create React App and most React setups.</p>
<hr>
<h2 id="bonus-hook-questions">BONUS HOOK QUESTIONS</h2>
<p><strong>Q45: What is the difference between <code>useEffect</code> and <code>useLayoutEffect</code>?</strong></p>
<table>
<thead>
<tr>
<th><code>useEffect</code></th>
<th><code>useLayoutEffect</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Runs <strong>asynchronously after</strong> the browser paints</td>
<td>Runs <strong>synchronously after</strong> DOM mutations but <strong>before</strong> the browser paints</td>
</tr>
<tr>
<td>Non-blocking ‚Äî doesn&#39;t delay visual updates</td>
<td>Blocking ‚Äî delays painting until it completes</td>
</tr>
<tr>
<td>Use for: data fetching, subscriptions, logging</td>
<td>Use for: DOM measurements, preventing visual flicker</td>
</tr>
</tbody>
</table>
<pre><code class="lang-jsx"><span class="hljs-comment">// useLayoutEffect runs BEFORE the user sees anything</span>
useLayoutEffect(() =&gt; {
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">height</span> = elementRef.current.getBoundingClientRect().<span class="hljs-built_in">height</span>;
  setHeight(<span class="hljs-built_in">height</span>); <span class="hljs-comment">// UI won't flicker because paint hasn't happened yet</span>
}, []);
</code></pre>
<p><strong>99% of the time, use <code>useEffect</code>.</strong> Only use <code>useLayoutEffect</code> when you need to measure or mutate the DOM before the user sees the result.</p>
<hr>
<p><strong>Q46: What is the difference between <code>useRef</code> and <code>createRef</code>?</strong></p>
<table>
<thead>
<tr>
<th><code>useRef</code></th>
<th><code>createRef</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>For <strong>functional</strong> components</td>
<td>For <strong>class</strong> components</td>
</tr>
<tr>
<td>Returns the <strong>same ref object</strong> across renders</td>
<td>Creates a <strong>new ref</strong> on every render</td>
</tr>
<tr>
<td>Persists between renders</td>
<td>Does not persist (unless stored in instance)</td>
</tr>
</tbody>
</table>
<pre><code class="lang-jsx"><span class="hljs-comment">// Functional ‚Äî useRef</span>
function <span class="hljs-type">MyComponent</span>() {
  const ref = useRef(<span class="hljs-literal">null</span>); <span class="hljs-comment">// Same object every render ‚úÖ</span>
}

<span class="hljs-comment">// Class ‚Äî createRef</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor() {
    <span class="hljs-keyword">this</span>.ref = <span class="hljs-type">React</span>.createRef(); <span class="hljs-comment">// Created once in constructor</span>
  }
}
</code></pre>
<p>If you use <code>createRef</code> in a functional component, it creates a <strong>new ref on every render</strong>, losing the previous value ‚Äî which defeats the purpose.</p>
<hr>
<p><strong>Q47: Can you use Hooks in class components?</strong></p>
<p><strong>No.</strong> Hooks are exclusively for <strong>functional components</strong> (and custom Hooks). If you need Hook-like functionality in a class component, you&#39;d need to either:</p>
<ul>
<li>Refactor to a functional component</li>
<li>Wrap the class component in a functional component that uses Hooks and passes data via props</li>
</ul>
<hr>
<p><strong>Q48: What is <code>useImperativeHandle</code> and when would you use it?</strong></p>
<p><code>useImperativeHandle</code> customizes the value exposed to a parent when using <code>ref</code> with <code>forwardRef</code>. Instead of exposing the entire DOM node, you expose only specific methods:</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> FancyInput = forwardRef((props, <span class="hljs-keyword">ref</span>) =&gt; {
  <span class="hljs-keyword">const</span> inputRef = useRef();

  useImperativeHandle(<span class="hljs-keyword">ref</span>, () =&gt; ({
    focus: () =&gt; inputRef.current.focus(),
    clear: () =&gt; { inputRef.current.<span class="hljs-keyword">value</span> = <span class="hljs-string">''</span>; }
    <span class="hljs-comment">// Parent can ONLY call focus() and clear(), not access the full DOM node</span>
  }));

  <span class="hljs-keyword">return</span> &lt;input <span class="hljs-keyword">ref</span>={inputRef} /&gt;;
});

<span class="hljs-comment">// Parent</span>
<span class="hljs-function">function <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">ref</span> = useRef();

  <span class="hljs-keyword">return</span> (
    &lt;&gt;
      &lt;FancyInput <span class="hljs-keyword">ref</span>={<span class="hljs-keyword">ref</span>} /&gt;
      &lt;button onClick={() =&gt; <span class="hljs-keyword">ref</span>.current.focus()}&gt;Focus&lt;/button&gt;
      &lt;button onClick={() =&gt; <span class="hljs-keyword">ref</span>.current.clear()}&gt;Clear&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>Use it when you want to <strong>restrict</strong> what the parent can do with the ref ‚Äî exposing a clean API instead of the raw DOM.</p>
<hr>
<p><strong>Q49: In what order do multiple <code>useEffect</code> hooks run?</strong></p>
<p>Multiple <code>useEffect</code> hooks in the same component run in the <strong>order they are defined</strong>, <strong>after</strong> the render is committed to the screen:</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>{
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Effect 1'</span>); <span class="hljs-comment">// Runs first</span>
  }, []);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Effect 2'</span>); <span class="hljs-comment">// Runs second</span>
  }, []);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Effect 3'</span>); <span class="hljs-comment">// Runs third</span>
  }, []);
}
<span class="hljs-comment">// Output: Effect 1, Effect 2, Effect 3</span>
</code></pre>
<p>Cleanup functions also run in order, <strong>before</strong> the corresponding new effects.</p>
<hr>
<p><strong>Q50: How do you replicate <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> with Hooks?</strong></p>
<pre><code class="lang-jsx"><span class="hljs-comment">// componentDidMount ‚Äî empty dependency array</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Mounted'</span>);
}, []);

<span class="hljs-comment">// componentDidUpdate ‚Äî specific dependency</span>
<span class="hljs-keyword">const</span> isFirstRender = useRef(<span class="hljs-literal">true</span>);
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (isFirstRender.current) {
    isFirstRender.current = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Skip on mount</span>
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'count updated'</span>);
}, [count]);

<span class="hljs-comment">// componentWillUnmount ‚Äî cleanup with empty dependency array</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Unmounting ‚Äî cleanup'</span>);
  };
}, []);

<span class="hljs-comment">// All three combined</span>
useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Mount or Update'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Cleanup before next effect or unmount'</span>);
}, [dependency]);
</code></pre>
<hr>
<h1 id="-component-communication-architecture-interview-q-a">üîπ Component Communication &amp; Architecture ‚Äî Interview Q&amp;A</h1>
<hr>
<h2 id="lifting-state-up">LIFTING STATE UP</h2>
<p><strong>Q1: What does &quot;Lifting State Up&quot; mean in React?</strong></p>
<p>Lifting state up means moving state from a child component to the nearest common parent component so that multiple children can share and stay in sync with the same data. Instead of each child managing its own copy of the state, the parent owns the state and passes it down as props along with a setter function. This ensures a single source of truth.</p>
<p>For example, if two sibling components both need access to the same temperature value, instead of each managing their own temperature state, you move that state to their common parent. The parent holds the state and passes it to both children as props. When one child needs to update the value, it calls a callback function received from the parent, which updates the parent&#39;s state and both children re-render with the new value.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">function</span> Parent() {
  const [temperature, setTemperature] = useState(<span class="hljs-string">''</span>);

  return (
    &lt;&gt;
      &lt;CelsiusInput temp={temperature} onTempChange={setTemperature} /&gt;
      &lt;FahrenheitInput temp={temperature} onTempChange={setTemperature} /&gt;
    &lt;/&gt;
  );
}

<span class="hljs-keyword">function</span> CelsiusInput({ temp, onTempChange }) {
  return &lt;input value={temp} onChange={e =&gt; onTempChange(e.target.value)} /&gt;;
}
</code></pre>
<p>The key idea is that data flows down via props and actions flow up via callbacks. The parent is always the single source of truth.</p>
<hr>
<p><strong>Q2: When should you lift state up?</strong></p>
<p>You should lift state up when two or more components need to reflect the same changing data. If sibling components need to communicate with each other, they cannot do so directly. The solution is to move the shared state to their closest common ancestor and pass it down. You should also lift state up when a parent component needs to know about or control what is happening inside a child component.</p>
<hr>
<p><strong>Q3: What are the downsides of lifting state up?</strong></p>
<p>The main downside is that as your application grows, you might end up lifting state very high in the component tree. This can lead to props drilling where intermediate components pass props they do not use. The parent component can also become bloated with too many state variables that logically belong elsewhere. When lifting state up causes too much props drilling or the parent becomes too complex, it is a signal to consider Context API or a state management library.</p>
<hr>
<h2 id="props-drilling">PROPS DRILLING</h2>
<p><strong>Q4: What is props drilling?</strong></p>
<p>Props drilling is the process of passing data from a parent component to a deeply nested child component through multiple intermediate components that do not actually need that data. They act as mere pass-through layers.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">const</span> [user, setUser] = useState({ name: <span class="hljs-string">'Rahul'</span> });

  <span class="hljs-keyword">return</span> &lt;Dashboard user={user} /&gt;;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dashboard</span><span class="hljs-params">({ user })</span> </span>{
  <span class="hljs-comment">// Dashboard doesn't use 'user', just passes it down</span>
  <span class="hljs-keyword">return</span> &lt;Sidebar user={user} /&gt;;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sidebar</span><span class="hljs-params">({ user })</span> </span>{
  <span class="hljs-comment">// Sidebar doesn't use 'user' either</span>
  <span class="hljs-keyword">return</span> &lt;UserProfile user={user} /&gt;;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserProfile</span><span class="hljs-params">({ user })</span> </span>{
  <span class="hljs-comment">// Only THIS component actually needs 'user'</span>
  <span class="hljs-keyword">return</span> &lt;h1&gt;{user.name}&lt;/h1&gt;;
}
</code></pre>
<p>Here, <code>Dashboard</code> and <code>Sidebar</code> receive and forward the <code>user</code> prop even though they have no use for it.</p>
<hr>
<p><strong>Q5: Why is props drilling a problem?</strong></p>
<p>Props drilling causes several issues. First, intermediate components become tightly coupled to data they do not care about, making them harder to reuse independently. Second, if the prop name or structure changes, you have to update every component in the chain, not just the producer and consumer. Third, it reduces readability because when you see a prop in a component, you cannot immediately tell whether that component uses it or just passes it along. Fourth, as the app grows, the drilling chains get longer and harder to maintain.</p>
<hr>
<p><strong>Q6: What are the solutions to props drilling?</strong></p>
<p>There are several solutions. The most common is the Context API which lets you provide a value at a high level and consume it in any nested component without passing through intermediaries. Component composition is another approach where you restructure your components so that the deeply nested child is rendered directly by the parent using children or render props, avoiding the intermediate layers entirely. State management libraries like Redux, Zustand, or Jotai provide global stores accessible from any component. Custom Hooks can also help by encapsulating the logic for accessing shared data.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Component composition approach</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [user, setUser] = useState({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Rahul'</span> });

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dashboard</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Sidebar</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Sidebar</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Dashboard</span>&gt;</span>
  );
}

function Dashboard({ children }) {
  return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"dashboard"</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;
}

function Sidebar({ children }) {
  return <span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>;
}</span>
</code></pre>
<p>Now <code>Dashboard</code> and <code>Sidebar</code> do not even know about <code>user</code>. They just render whatever children they receive.</p>
<hr>
<h2 id="context-api">CONTEXT API</h2>
<p><strong>Q7: What is the Context API?</strong></p>
<p>The Context API is a built-in React feature that provides a way to share data across the component tree without explicitly passing props at every level. It consists of three parts. First, <code>React.createContext</code> creates a context object. Second, <code>Context.Provider</code> wraps the part of the tree that needs access to the value and supplies that value. Third, <code>useContext</code> hook or <code>Context.Consumer</code> is used by any descendant component to read the current value.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Step 1: Create</span>
<span class="hljs-keyword">const</span> ThemeContext = React.createContext(<span class="hljs-string">'light'</span>);

<span class="hljs-comment">// Step 2: Provide</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">const</span> [theme, setTheme] = useState(<span class="hljs-string">'dark'</span>);

  <span class="hljs-keyword">return</span> (
    &lt;ThemeContext.Provider value={{ theme, setTheme }}&gt;
      &lt;Page /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

<span class="hljs-comment">// Step 3: Consume (anywhere in the tree)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ThemedButton</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">const</span> { theme, setTheme } = useContext(ThemeContext);

  <span class="hljs-keyword">return</span> (
    &lt;button
      className={theme}
      onClick={() =&gt; setTheme(theme === <span class="hljs-string">'dark'</span> ? <span class="hljs-string">'light'</span> : <span class="hljs-string">'dark'</span>)}
    &gt;
      Toggle Theme
    &lt;/button&gt;
  );
}
</code></pre>
<hr>
<p><strong>Q8: What is the default value in <code>createContext</code> used for?</strong></p>
<p>The default value passed to <code>createContext</code> is used only when a component calls <code>useContext</code> but there is no matching Provider above it in the tree. It acts as a fallback. If every consumer is always wrapped in a Provider, the default value is never used. It is mainly helpful for testing components in isolation or as documentation of the expected shape of the context value.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> ThemeContext = React.createContext(<span class="hljs-string">'light'</span>);
<span class="hljs-comment">// If no &lt;ThemeContext.Provider&gt; exists above a component,</span>
<span class="hljs-comment">// useContext(ThemeContext) returns 'light'</span>
</code></pre>
<hr>
<p><strong>Q9: Can you have multiple Contexts in one application?</strong></p>
<p>Yes. You can create and use as many contexts as you need. It is actually recommended to split contexts by concern rather than putting everything into a single context. This prevents unnecessary re-renders because a component only re-renders when the specific context it consumes changes.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> AuthContext = React.createContext(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> ThemeContext = React.createContext(<span class="hljs-string">'light'</span>);
<span class="hljs-keyword">const</span> LanguageContext = React.createContext(<span class="hljs-string">'en'</span>);

<span class="hljs-function">function <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;AuthContext.Provider <span class="hljs-keyword">value</span>={authData}&gt;
      &lt;ThemeContext.Provider <span class="hljs-keyword">value</span>={themeData}&gt;
        &lt;LanguageContext.Provider <span class="hljs-keyword">value</span>={langData}&gt;
          &lt;MainApp /&gt;
        &lt;/LanguageContext.Provider&gt;
      &lt;/ThemeContext.Provider&gt;
    &lt;/AuthContext.Provider&gt;
  );
}
</code></pre>
<hr>
<p><strong>Q10: What are the performance concerns with Context API?</strong></p>
<p>When the Provider&#39;s value changes, every component that consumes that context re-renders regardless of whether the specific piece of data it uses has changed. If you put an object with multiple properties as the value, changing any one property causes all consumers to re-render.</p>
<p>To mitigate this, you can split contexts so that frequently changing values are in their own context. You can memoize the context value object using <code>useMemo</code> to prevent unnecessary reference changes. You can also use state management libraries for high-frequency updates.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// ‚ùå Problem: new object reference on every render of App</span>
&lt;MyContext.Provider value={{ user, theme }}&gt;

<span class="hljs-comment">// ‚úÖ Memoize to keep the same reference when values haven't changed</span>
<span class="hljs-keyword">const</span> contextValue = useMemo(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({ user, theme }), [user, theme]);
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{contextValue}</span>&gt;</span></span>
</code></pre>
<hr>
<p><strong>Q11: Context API vs Redux ‚Äî when to use which?</strong></p>
<p>Context API is best for low-frequency updates like theme, locale, authentication status, or user preferences. It is simple to set up and requires no extra libraries. Redux is better for complex state logic with many actions, frequent updates, middleware needs like async operations, time-travel debugging, or when multiple unrelated parts of the app need to read and write the same state frequently. Context was not designed to be a full state management solution. It is a dependency injection mechanism. For medium complexity, libraries like Zustand or Jotai offer a good middle ground.</p>
<hr>
<h2 id="higher-order-components-hoc-">HIGHER-ORDER COMPONENTS (HOC)</h2>
<p><strong>Q12: What is a Higher-Order Component?</strong></p>
<p>A Higher-Order Component is a function that takes a component as input and returns a new enhanced component. It is a pattern for reusing component logic. HOCs do not modify the original component. They wrap it in a new component that adds extra behavior or data.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLogger</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EnhancedComponent</span>(<span class="hljs-params">props</span>) </span>{
    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${WrappedComponent.name}</span> mounted`</span>);
    }, []);

    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...props</span>} /&gt;</span>;
  };
}

// Usage
const ButtonWithLogger = withLogger(Button);
const CardWithLogger = withLogger(Card);</span>
</code></pre>
<p>The naming convention is to prefix with <code>with</code> to indicate it is an HOC.</p>
<hr>
<p><strong>Q13: What are real-world use cases for HOCs?</strong></p>
<p>Common use cases include authentication checks where you wrap a component to redirect unauthenticated users, adding loading spinners while data is being fetched, injecting data or configuration like theme or user info, logging and analytics tracking, and authorization where you check if a user has permission to view a component.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withAuth</span><span class="hljs-params">(WrappedComponent)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AuthenticatedComponent</span><span class="hljs-params">(props)</span> </span>{
    <span class="hljs-keyword">const</span> { user } = useContext(AuthContext);

    <span class="hljs-keyword">if</span> (!user) {
      <span class="hljs-keyword">return</span> &lt;Navigate to=<span class="hljs-string">"/login"</span> /&gt;;
    }

    <span class="hljs-keyword">return</span> &lt;WrappedComponent {...props} user={user} /&gt;;
  };
}

<span class="hljs-keyword">const</span> ProtectedDashboard = withAuth(Dashboard);
</code></pre>
<hr>
<p><strong>Q14: What are the downsides of HOCs?</strong></p>
<p>HOCs have several downsides. Wrapper hell is one where multiple HOCs create deeply nested component trees that are hard to debug in React DevTools. Prop name collisions can occur when two HOCs inject props with the same name, silently overwriting each other. HOCs also obscure the component structure because it is not immediately clear what props a component receives or where they come from. Static methods and refs do not automatically pass through and require extra handling. Because of these issues, the React team now recommends Custom Hooks over HOCs for most logic reuse scenarios.</p>
<hr>
<p><strong>Q15: How are HOCs different from Custom Hooks?</strong></p>
<p>HOCs wrap components and add behavior by injecting props. They operate at the component level and create additional wrapper elements in the component tree. Custom Hooks extract and share stateful logic by being called inside a component. They operate at the logic level and add no extra elements to the tree. Custom Hooks are more transparent because you can see exactly what values they return. They do not cause wrapper hell or prop collisions. For most modern React development, Custom Hooks are the preferred approach for logic reuse.</p>
<hr>
<h2 id="render-props">RENDER PROPS</h2>
<p><strong>Q16: What is the Render Props pattern?</strong></p>
<p>Render Props is a pattern where a component receives a function as a prop (often called <code>render</code> or <code>children</code>) and calls that function to determine what to render. It allows sharing stateful logic between components by letting the consumer decide the UI while the provider handles the logic.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MouseTracker</span>(<span class="hljs-params">{ render }</span>) </span>{
  <span class="hljs-keyword">const</span> [position, setPosition] = useState({ <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> });

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> handleMouseMove = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      setPosition({ <span class="hljs-attr">x</span>: e.clientX, <span class="hljs-attr">y</span>: e.clientY });
    };
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, handleMouseMove);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'mousemove'</span>, handleMouseMove);
  }, []);

  <span class="hljs-keyword">return</span> render(position);
}

<span class="hljs-comment">// Usage ‚Äî consumer decides the UI</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MouseTracker</span>
      <span class="hljs-attr">render</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">x</span>, <span class="hljs-attr">y</span> }) =&gt;</span> (
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Mouse is at ({x}, {y})<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      )}
    /&gt;
  );
}</span>
</code></pre>
<hr>
<p><strong>Q17: Can you use <code>children</code> as a render prop?</strong></p>
<p>Yes. Instead of a named <code>render</code> prop, you can use the <code>children</code> prop as a function. This is sometimes called &quot;function as children&quot; or &quot;children as a function&quot; pattern.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MouseTracker</span>(<span class="hljs-params">{ children }</span>) </span>{
  <span class="hljs-keyword">const</span> [position, setPosition] = useState({ <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> });

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> handleMouseMove = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> setPosition({ <span class="hljs-attr">x</span>: e.clientX, <span class="hljs-attr">y</span>: e.clientY });
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, handleMouseMove);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'mousemove'</span>, handleMouseMove);
  }, []);

  <span class="hljs-keyword">return</span> children(position);
}

<span class="hljs-comment">// Usage</span>
&lt;MouseTracker&gt;
  {({ x, y }) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Position: {x}, {y}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>}
&lt;<span class="hljs-regexp">/MouseTracker&gt;</span>
</code></pre>
<hr>
<p><strong>Q18: Render Props vs HOCs vs Custom Hooks ‚Äî which to choose?</strong></p>
<p>All three patterns solve the same problem of sharing stateful logic between components. Render Props and HOCs were the primary patterns before Hooks existed. Custom Hooks are now the recommended approach because they are simpler, do not create wrapper elements, avoid prop collisions, and are easier to compose. Render Props are still useful when you need to share logic and the consumer needs full control over what gets rendered. HOCs are useful when you need to transparently enhance a component without changing its interface. However, for the majority of use cases in modern React, Custom Hooks are the cleanest solution.</p>
<hr>
<h2 id="controlled-components">CONTROLLED COMPONENTS</h2>
<p><strong>Q19: What is a controlled component?</strong></p>
<p>A controlled component is a form element whose value is controlled by React state. The component&#39;s current value is stored in state, and every change goes through a state update. React becomes the single source of truth for the input&#39;s value.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span></span> LoginForm() {
  const [email, setEmail] = useState(<span class="hljs-string">''</span>);
  const [password, setPassword] = useState(<span class="hljs-string">''</span>);

  const handleSubmit = (e) =&gt; {
    e.preventDefault();
    console.<span class="hljs-built_in">log</span>(email, password);
  };

  <span class="hljs-keyword">return</span> (
    &lt;<span class="hljs-keyword">form</span> onSubmit={handleSubmit}&gt;
      &lt;input
        <span class="hljs-keyword">type</span>=<span class="hljs-string">"email"</span>
        <span class="hljs-keyword">value</span>={email}
        onChange={(e) =&gt; setEmail(e.<span class="hljs-keyword">target</span>.<span class="hljs-keyword">value</span>)}
      /&gt;
      &lt;input
        <span class="hljs-keyword">type</span>=<span class="hljs-string">"password"</span>
        <span class="hljs-keyword">value</span>={password}
        onChange={(e) =&gt; setPassword(e.<span class="hljs-keyword">target</span>.<span class="hljs-keyword">value</span>)}
      /&gt;
      &lt;button <span class="hljs-keyword">type</span>=<span class="hljs-string">"submit"</span>&gt;Login&lt;/button&gt;
    &lt;/<span class="hljs-keyword">form</span>&gt;
  );
}
</code></pre>
<p>Every keystroke triggers <code>onChange</code>, which updates state, which re-renders the component with the new value. The input always reflects the React state.</p>
<hr>
<p><strong>Q20: Why are controlled components preferred?</strong></p>
<p>Controlled components are preferred because React has full control over the form data at all times. You can instantly validate input, conditionally disable buttons, enforce formatting like uppercasing or character limits, easily reset form fields, and access the current value without querying the DOM. The form data lives in state, so it integrates naturally with React&#39;s data flow and can be easily passed to other components or submitted to an API.</p>
<hr>
<h2 id="uncontrolled-components">UNCONTROLLED COMPONENTS</h2>
<p><strong>Q21: What is an uncontrolled component?</strong></p>
<p>An uncontrolled component is a form element that manages its own internal state through the DOM, just like traditional HTML forms. Instead of writing an <code>onChange</code> handler for every state update, you use a <code>ref</code> to access the DOM node&#39;s value when you need it, typically on form submission.</p>
<pre><code class="lang-jsx">function LoginForm() {
  <span class="hljs-keyword">const</span> emailRef = useRef();
  <span class="hljs-keyword">const</span> passwordRef = useRef();

  <span class="hljs-keyword">const</span> handleSubmit = (<span class="hljs-keyword">e</span>) =&gt; {
    <span class="hljs-keyword">e</span>.preventDefault();
    console.<span class="hljs-built_in">log</span>(emailRef.current.value, passwordRef.current.value);
  };

  <span class="hljs-keyword">return</span> (
    &lt;<span class="hljs-keyword">form</span> onSubmit={handleSubmit}&gt;
      &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"email"</span> ref={emailRef} defaultValue=<span class="hljs-string">""</span> /&gt;
      &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"password"</span> ref={passwordRef} defaultValue=<span class="hljs-string">""</span> /&gt;
      &lt;button <span class="hljs-keyword">type</span>=<span class="hljs-string">"submit"</span>&gt;Login&lt;/button&gt;
    &lt;/<span class="hljs-keyword">form</span>&gt;
  );
}
</code></pre>
<p>Notice the use of <code>defaultValue</code> instead of <code>value</code>. This sets the initial value but lets the DOM handle subsequent changes.</p>
<hr>
<p><strong>Q22: What is the difference between controlled and uncontrolled components?</strong></p>
<p>In controlled components, the form data is handled by React state. You use <code>value</code> and <code>onChange</code> on inputs. React is the source of truth. You can validate on every keystroke and have instant access to the current value at any time. In uncontrolled components, the form data is handled by the DOM itself. You use <code>ref</code> and <code>defaultValue</code>. The DOM is the source of truth. You typically access the value only when needed like on form submission. Controlled components give you more power and flexibility but require more code. Uncontrolled components are simpler but offer less control.</p>
<hr>
<p><strong>Q23: When would you use an uncontrolled component?</strong></p>
<p>Uncontrolled components are suitable when you are integrating with non-React code or third-party DOM libraries, when you have a simple form where you only need the value on submission, when working with file inputs since <code>&lt;input type=&quot;file&quot; /&gt;</code> is always uncontrolled because its value is read-only and cannot be set programmatically, and when you want to avoid re-rendering on every keystroke for performance in rare cases.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// File input is always uncontrolled</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FileUpload</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> fileRef = useRef();

  <span class="hljs-keyword">const</span> handleSubmit = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.preventDefault();
    <span class="hljs-keyword">const</span> file = fileRef.current.files[<span class="hljs-number">0</span>];
    <span class="hljs-built_in">console</span>.log(file.name);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{fileRef}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Upload<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  );
}</span>
</code></pre>
<hr>
<h2 id="refs">REFS</h2>
<p><strong>Q24: What are Refs in React?</strong></p>
<p>Refs provide a way to access DOM nodes or React elements directly. They give you an escape hatch from React&#39;s declarative model when you need to imperatively interact with a child component or a DOM element. Refs are created using <code>useRef</code> in functional components or <code>React.createRef</code> in class components. The ref object has a <code>.current</code> property that holds the actual reference.</p>
<hr>
<p><strong>Q25: What are the common use cases for Refs?</strong></p>
<p>The most common use cases include managing focus, text selection, or media playback. Triggering imperative animations. Integrating with third-party DOM libraries like D3 or jQuery plugins. Storing values that need to persist across renders but should not trigger re-renders, such as timer IDs, previous state values, or instance variables.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VideoPlayer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> videoRef = useRef(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">const</span> play = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> videoRef.current.play();
  <span class="hljs-keyword">const</span> pause = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> videoRef.current.pause();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{videoRef}</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"video.mp4"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{play}</span>&gt;</span>Play<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{pause}</span>&gt;</span>Pause<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}</span>
</code></pre>
<hr>
<p><strong>Q26: What is <code>forwardRef</code> and why is it needed?</strong></p>
<p>By default, you cannot attach a <code>ref</code> to a functional component because functional components do not have instances. <code>forwardRef</code> is a React API that lets a component receive a <code>ref</code> from its parent and forward it to a DOM element inside.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Without forwardRef ‚Äî ref would be null</span>
<span class="hljs-keyword">const</span> FancyInput = ({ placeholder }) =&gt; {
  <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">input</span> placeholder={placeholder} /&gt;;
};

<span class="hljs-comment">// With forwardRef ‚Äî parent can access the &lt;input&gt; DOM node</span>
<span class="hljs-keyword">const</span> FancyInput = React<span class="hljs-variable">.forwardRef</span>(({ placeholder }, <span class="hljs-keyword">ref</span>) =&gt; {
  <span class="hljs-keyword">return</span> &lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">ref</span>={<span class="hljs-keyword">ref</span>} placeholder={placeholder} /&gt;;
});

<span class="hljs-comment">// Parent</span>
<span class="hljs-keyword">function</span> Form() {
  <span class="hljs-keyword">const</span> inputRef = useRef(<span class="hljs-literal">null</span>);

  useEffect(() =&gt; {
    inputRef<span class="hljs-variable">.current</span><span class="hljs-variable">.focus</span>(); <span class="hljs-comment">// Works because of forwardRef</span>
  }, []);

  <span class="hljs-keyword">return</span> &lt;FancyInput <span class="hljs-keyword">ref</span>={inputRef} placeholder=<span class="hljs-string">"Enter name"</span> /&gt;;
}
</code></pre>
<p><code>forwardRef</code> is essential when building reusable component libraries where consumers might need direct DOM access.</p>
<hr>
<p><strong>Q27: What is the difference between callback refs and object refs?</strong></p>
<p>Object refs are created with <code>useRef</code> or <code>createRef</code> and have a <code>.current</code> property. They are the most common approach. Callback refs are functions that React calls with the DOM element when it mounts and with <code>null</code> when it unmounts. Callback refs give you more fine-grained control over when refs are set and unset.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Object ref</span>
<span class="hljs-keyword">const</span> myRef = useRef(<span class="hljs-literal">null</span>);
&lt;div <span class="hljs-keyword">ref</span>={myRef} /&gt;

<span class="hljs-comment">// Callback ref</span>
<span class="hljs-keyword">const</span> [node, setNode] = useState(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">const</span> callbackRef = useCallback((element) =&gt; {
  <span class="hljs-keyword">if</span> (element) {
    console.log(<span class="hljs-string">'Element mounted:'</span>, element.getBoundingClientRect());
  }
  setNode(element);
}, []);

&lt;div <span class="hljs-keyword">ref</span>={callbackRef} /&gt;
</code></pre>
<p>Callback refs are useful when you need to perform an action the moment an element is attached to or removed from the DOM, or when you need to measure a DOM element as soon as it appears.</p>
<hr>
<h2 id="portals">PORTALS</h2>
<p><strong>Q28: What are React Portals?</strong></p>
<p>Portals provide a way to render a child component into a DOM node that exists outside the parent component&#39;s DOM hierarchy. Normally, a component renders into the nearest parent DOM element. With portals, you can break out of this hierarchy and render anywhere in the DOM while still maintaining React&#39;s event bubbling and context behavior.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { createPortal } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Modal</span>(<span class="hljs-params">{ children, isOpen }</span>) </span>{
  <span class="hljs-keyword">if</span> (!isOpen) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">return</span> createPortal(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"modal-overlay"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"modal-content"</span>&gt;</span>
        {children}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'modal-root'</span>) <span class="hljs-comment">// Renders here, not in parent</span>
  );
}
</code></pre>
<p>In your HTML, you would have a separate root element:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Main app renders here --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"modal-root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-comment">&lt;!-- Portals render here --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<hr>
<p><strong>Q29: Why are Portals needed? What problems do they solve?</strong></p>
<p>Portals solve CSS and DOM hierarchy issues. Modals, tooltips, dropdowns, and toast notifications often need to visually appear on top of everything else. If they are nested deep inside the component tree, parent elements with <code>overflow: hidden</code>, <code>z-index</code> stacking contexts, or <code>position: relative</code> can clip or hide them. By rendering into a separate DOM node at the top level, these elements escape any CSS constraints of their parent containers while still being logically part of the React component tree.</p>
<hr>
<p><strong>Q30: Do events bubble normally through Portals?</strong></p>
<p>Yes. Even though the portal renders into a different DOM node, React&#39;s synthetic event system maintains the original component hierarchy for event bubbling. An event fired inside a portal will bubble up through the React tree, not the DOM tree. This means a click event inside a portal can be caught by an <code>onClick</code> handler on a React ancestor even though they are in completely different parts of the actual DOM.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Caught in Parent!'</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Modal</span> <span class="hljs-attr">isOpen</span>=<span class="hljs-string">{true}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        {/* Click bubbles to Parent's onClick even though
            Modal renders in a different DOM node */}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Modal</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<hr>
<p><strong>Q31: Do Context values work inside Portals?</strong></p>
<p>Yes. Since portals are still part of the React component tree regardless of where they render in the DOM, they have full access to Context values provided by their React ancestors. This is one of the key advantages of portals over manually appending elements to the DOM.</p>
<hr>
<h2 id="error-boundaries">ERROR BOUNDARIES</h2>
<p><strong>Q32: What are Error Boundaries?</strong></p>
<p>Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application. Without error boundaries, a runtime error in any component would unmount the entire React tree, showing a blank screen to the user.</p>
<hr>
<p><strong>Q33: How do you create an Error Boundary?</strong></p>
<p>Error Boundaries can only be created using class components. There is no Hook equivalent yet. A class component becomes an Error Boundary when it implements either or both of two lifecycle methods: <code>static getDerivedStateFromError</code> for rendering a fallback UI, and <code>componentDidCatch</code> for logging the error.</p>
<pre><code class="lang-jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = { hasError: <span class="hljs-literal">false</span>, error: <span class="hljs-literal">null</span> };
  }

  static getDerivedStateFromError(error) {
    <span class="hljs-comment">// Update state to show fallback UI on next render</span>
    <span class="hljs-keyword">return</span> { hasError: <span class="hljs-literal">true</span>, error };
  }

  componentDidCatch(error, errorInfo) {
    <span class="hljs-comment">// Log error to an error reporting service</span>
    console.error(<span class="hljs-symbol">'Error</span> caught:', error);
    console.error(<span class="hljs-symbol">'Component</span> stack:', errorInfo.componentStack);
    <span class="hljs-comment">// logErrorToService(error, errorInfo);</span>
  }

  render() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.hasError) {
      <span class="hljs-keyword">return</span> (
        <span class="hljs-keyword">this</span>.props.fallback || &lt;h1&gt;<span class="hljs-type">Something</span> went wrong.&lt;/h1&gt;
      );
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.children;
  }
}

<span class="hljs-comment">// Usage</span>
&lt;<span class="hljs-type">ErrorBoundary</span> fallback={&lt;p&gt;<span class="hljs-type">Oops</span>! <span class="hljs-type">Error</span> occurred.&lt;/p&gt;}&gt;
  &lt;<span class="hljs-type">UserProfile</span> /&gt;
  &lt;<span class="hljs-type">Dashboard</span> /&gt;
&lt;/<span class="hljs-type">ErrorBoundary</span>&gt;
</code></pre>
<hr>
<p><strong>Q34: What errors do Error Boundaries NOT catch?</strong></p>
<p>Error Boundaries do not catch errors in five scenarios. First, event handlers because they do not happen during rendering so React can recover from them without a fallback UI. You should use regular try-catch inside event handlers. Second, asynchronous code like <code>setTimeout</code>, <code>setInterval</code>, <code>requestAnimationFrame</code> callbacks, and Promise rejections. Third, server-side rendering. Fourth, errors thrown in the Error Boundary component itself rather than in its children. Fifth, errors in code outside of the React tree.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Button</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Error boundaries won't catch this</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Click error'</span>);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// Handle it yourself</span>
      <span class="hljs-built_in">console</span>.error(error);
    }
  };

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}
</code></pre>
<hr>
<p><strong>Q35: Why can&#39;t Error Boundaries be functional components?</strong></p>
<p>Because <code>getDerivedStateFromError</code> and <code>componentDidCatch</code> are class-based lifecycle methods with no Hook equivalents yet. The React team has discussed adding a <code>useErrorBoundary</code> hook or similar API but as of now it has not been implemented. If you want to use a functional-component-like API, libraries like <code>react-error-boundary</code> provide a wrapper that gives you a simpler interface.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Using react-error-boundary library</span>
<span class="hljs-keyword">import</span> { ErrorBoundary } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-error-boundary'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ErrorFallback</span>(<span class="hljs-params">{ error, resetErrorBoundary }</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Something went wrong: {error.message}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{resetErrorBoundary}</span>&gt;</span>Try again<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

&lt;ErrorBoundary FallbackComponent={ErrorFallback}&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span>
</code></pre>
<hr>
<p><strong>Q36: Can you have multiple Error Boundaries in an app?</strong></p>
<p>Yes, and it is recommended. You can wrap different sections of your app with separate Error Boundaries so that an error in one section does not take down the entire page. For example, you might have one around the sidebar, one around the main content area, and one around a chat widget. If the chat crashes, the rest of the app continues working.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">p</span>&gt;</span>Header error<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">p</span>&gt;</span>Content error<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">p</span>&gt;</span>Sidebar error<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">Sidebar</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>The granularity of Error Boundaries depends on your application&#39;s needs. You can be as broad or as specific as you want.</p>
<hr>
<p><strong>Q37: What is the difference between <code>getDerivedStateFromError</code> and <code>componentDidCatch</code>?</strong></p>
<p><code>getDerivedStateFromError</code> is a static method called during the render phase. It receives the error and returns an object to update state. It is used to render a fallback UI. It should be a pure function with no side effects. <code>componentDidCatch</code> is an instance method called during the commit phase after the DOM has been updated. It receives both the error and an info object containing the component stack trace. It is used for side effects like logging errors to an external service. Both can be used together where <code>getDerivedStateFromError</code> handles the UI fallback and <code>componentDidCatch</code> handles the logging.</p>
<hr>
<h2 id="bonus-architecture-questions">BONUS ARCHITECTURE QUESTIONS</h2>
<p><strong>Q38: What is component composition and why is it important?</strong></p>
<p>Component composition is the practice of building complex UIs by combining simpler, smaller components together. Instead of creating large monolithic components or relying on inheritance, you compose behavior by nesting components and using patterns like children, render props, and specialized components. React strongly favors composition over inheritance. Composition keeps components focused on a single responsibility, makes them more reusable, and makes the codebase easier to understand and test.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Composition: Card doesn't know its content ahead of time</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Card</span>(<span class="hljs-params">{ title, children }</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"card"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"card-body"</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// Specialized components built through composition</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserCard</span>(<span class="hljs-params">{ user }</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">title</span>=<span class="hljs-string">{user.name}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{user.email}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{user.role}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span>
  );
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProductCard</span>(<span class="hljs-params">{ product }</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span> <span class="hljs-attr">title</span>=<span class="hljs-string">{product.name}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Price: ${product.price}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Add to Cart<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Card</span>&gt;</span></span>
  );
}
</code></pre>
<hr>
<p><strong>Q39: Why does React prefer composition over inheritance?</strong></p>
<p>The React team has stated that they have not found use cases where component inheritance is necessary. Composition achieves everything inheritance can and more. With composition, you pass components as children or props, creating flexible and reusable patterns. With inheritance, you create rigid hierarchies that are difficult to change. If you need to share non-UI logic between components, the recommendation is to extract it into a plain JavaScript module or a custom Hook and import it, rather than creating a base class.</p>
<hr>
<p><strong>Q40: How do you decide between lifting state up, Context, and Redux?</strong></p>
<p>Start with the simplest approach and scale up only when needed. If two or three sibling components need shared data, lift state up to their common parent. If the data needs to be accessed by many components at different nesting levels and updates infrequently, use Context API. If the state is complex with many actions, updates frequently, needs middleware for async operations, or would benefit from dev tools like time-travel debugging, use Redux or a dedicated state management library. The general principle is to keep state as close as possible to where it is used and only elevate it when necessary.</p>
<hr>
<h1 id="-routing-state-management-interview-q-a">üîπ Routing &amp; State Management ‚Äî Interview Q&amp;A</h1>
<hr>
<h2 id="react-router">REACT ROUTER</h2>
<p><strong>Q1: What is React Router?</strong></p>
<p>React Router is the most popular third-party routing library for React applications. It enables navigation between different views or pages in a single-page application without a full page reload. When the URL changes, React Router matches it against defined routes and renders the corresponding component. The browser URL updates, the back and forward buttons work, and bookmarking works ‚Äî all while keeping the SPA experience where only the relevant parts of the page update.</p>
<hr>
<p><strong>Q2: How does routing work in a single-page application compared to traditional multi-page applications?</strong></p>
<p>In a traditional multi-page application, every navigation sends a request to the server, which responds with an entirely new HTML page. The browser reloads completely. In a single-page application with React Router, the initial page load fetches the entire application. After that, navigation is handled entirely on the client side. When the user clicks a link, React Router intercepts it, prevents the default browser navigation, updates the URL using the browser&#39;s History API, and renders the matching component without any server request or page reload. This makes transitions faster and smoother.</p>
<hr>
<p><strong>Q3: What are the core components of React Router v6?</strong></p>
<p>React Router v6 has several core components. <code>BrowserRouter</code> wraps the entire application and enables routing using the HTML5 History API. <code>Routes</code> replaces the older <code>Switch</code> component and is a container for all route definitions. <code>Route</code> defines a mapping between a URL path and a component. <code>Link</code> renders an anchor tag that navigates without a full page reload. <code>NavLink</code> is like <code>Link</code> but adds active styling when the current URL matches. <code>Navigate</code> is used for programmatic redirects within JSX. <code>Outlet</code> renders the matched child route component in nested routing.</p>
<pre><code class="lang-jsx"><span class="xml">import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

function App() {
  return (
    <span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/users"</span>&gt;</span>Users<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>

      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/about"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/users"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Users</span> /&gt;</span>} /&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">NotFound</span> /&gt;</span>} /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span>
  );
}</span>
</code></pre>
<hr>
<p><strong>Q4: What is the difference between <code>Link</code> and an anchor tag <code>&lt;a&gt;</code>?</strong></p>
<p>An anchor tag <code>&lt;a href=&quot;/about&quot;&gt;</code> triggers a full page reload. The browser sends a new request to the server, the entire page unloads and reloads, and all React state is lost. <code>Link</code> from React Router uses the History API to change the URL without a page reload. It prevents the default browser behavior, updates the URL, and React Router renders the matching component. The app state is preserved, and the transition is instant. You should always use <code>Link</code> or <code>NavLink</code> for internal navigation and only use <code>&lt;a&gt;</code> for external links that go to different websites.</p>
<hr>
<p><strong>Q5: What is the difference between <code>Link</code> and <code>NavLink</code>?</strong></p>
<p><code>NavLink</code> is a special version of <code>Link</code> that knows whether it matches the current URL. When it matches, it automatically applies an <code>active</code> class by default, or you can customize the styling using the <code>className</code> or <code>style</code> props which receive an <code>isActive</code> boolean.</p>
<pre><code class="lang-jsx">&lt;NavLink
  <span class="hljs-keyword">to</span>=<span class="hljs-string">"/about"</span>
  className={({ isActive }) =&gt; isActive ? <span class="hljs-string">'active-link'</span> : <span class="hljs-string">'normal-link'</span>}
&gt;
  About
&lt;/NavLink&gt;

&lt;NavLink
  <span class="hljs-keyword">to</span>=<span class="hljs-string">"/about"</span>
  style={({ isActive }) =&gt; ({
    fontWeight: isActive ? <span class="hljs-string">'bold'</span> : <span class="hljs-string">'normal'</span>,
    color: isActive ? <span class="hljs-string">'red'</span> : <span class="hljs-string">'black'</span>
  })}
&gt;
  About
&lt;/NavLink&gt;
</code></pre>
<p><code>NavLink</code> is ideal for navigation menus where you want to highlight the currently active page. <code>Link</code> is fine for regular navigation where active styling is not needed.</p>
<hr>
<p><strong>Q6: What is the <code>*</code> wildcard route used for?</strong></p>
<p>The <code>*</code> path matches any URL that has not been matched by any other defined route. It is used to create a catch-all or 404 Not Found page. It should always be placed as the last route so that it only matches when no other route does.</p>
<pre><code class="lang-jsx"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Home</span> /&gt;</span>} /&gt;
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/about"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">About</span> /&gt;</span>} /&gt;
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">NotFound</span> /&gt;</span>} /&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span>
</code></pre>
<hr>
<p><strong>Q7: How do you navigate programmatically in React Router v6?</strong></p>
<p>You use the <code>useNavigate</code> hook which returns a function that lets you navigate to a different route from within event handlers or effects.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoginForm</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> navigate = useNavigate();

  <span class="hljs-keyword">const</span> handleSubmit = <span class="hljs-keyword">async</span> (e) =&gt; {
    e.preventDefault();
    <span class="hljs-keyword">const</span> success = <span class="hljs-keyword">await</span> loginUser(credentials);
    <span class="hljs-keyword">if</span> (success) {
      navigate(<span class="hljs-string">'/dashboard'</span>);         <span class="hljs-comment">// Navigate to dashboard</span>
      <span class="hljs-comment">// navigate('/dashboard', { replace: true }); // Replace history entry</span>
      <span class="hljs-comment">// navigate(-1);                // Go back one page</span>
      <span class="hljs-comment">// navigate(-2);                // Go back two pages</span>
    }
  };

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>;
}
</code></pre>
<p>The <code>replace: true</code> option replaces the current history entry instead of pushing a new one. This is useful after login so that the user cannot press the back button to return to the login page.</p>
<hr>
<p><strong>Q8: What is the difference between <code>useNavigate</code> and <code>Navigate</code> component?</strong></p>
<p><code>useNavigate</code> is a hook that returns a function for programmatic navigation inside event handlers, effects, or any JavaScript logic. <code>Navigate</code> is a component that performs navigation when it is rendered. It is used for declarative redirects directly in JSX.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// useNavigate ‚Äî imperative, inside logic</span>
<span class="hljs-keyword">const</span> navigate = useNavigate();
<span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> navigate(<span class="hljs-string">'/home'</span>);

<span class="hljs-comment">// Navigate ‚Äî declarative, rendered in JSX</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProtectedRoute</span>(<span class="hljs-params">{ children }</span>) </span>{
  <span class="hljs-keyword">const</span> { user } = useAuth();

  <span class="hljs-keyword">if</span> (!user) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">replace</span> /&gt;</span>;
  }

  return children;
}</span>
</code></pre>
<p>Use <code>Navigate</code> when the redirect is a direct result of rendering logic. Use <code>useNavigate</code> when the redirect is triggered by user actions or async operations.</p>
<hr>
<p><strong>Q9: What are nested routes and how do they work?</strong></p>
<p>Nested routes allow you to define routes inside other routes, creating a parent-child relationship. The parent route renders a layout component that contains an <code>Outlet</code> component. The <code>Outlet</code> acts as a placeholder where the matched child route component will be rendered.</p>
<pre><code class="lang-jsx"><span class="xml">function App() {
  return (
    <span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/dashboard"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">DashboardLayout</span> /&gt;</span>}&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">index</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">DashboardHome</span> /&gt;</span>} /&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"profile"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Profile</span> /&gt;</span>} /&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"settings"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Settings</span> /&gt;</span>} /&gt;
        <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span>
  );
}

function DashboardLayout() {
  return (
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/dashboard"</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/dashboard/profile"</span>&gt;</span>Profile<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/dashboard/settings"</span>&gt;</span>Settings<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"content"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span> /&gt;</span>  {/* Child route renders here */}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}</span>
</code></pre>
<p>When the URL is <code>/dashboard</code>, the <code>DashboardLayout</code> renders with <code>DashboardHome</code> in the Outlet. When the URL is <code>/dashboard/profile</code>, the same layout renders but <code>Profile</code> appears in the Outlet. The layout stays mounted and only the Outlet content changes, which is efficient for shared layouts like sidebars and headers.</p>
<hr>
<p><strong>Q10: What is the <code>index</code> route?</strong></p>
<p>An index route is a child route that renders when the parent route&#39;s path is matched exactly, without any additional path segment. It acts as the default child route. In the nested routes example above, <code>&lt;Route index element={&lt;DashboardHome /&gt;} /&gt;</code> renders when the URL is exactly <code>/dashboard</code> with no additional path after it.</p>
<hr>
<p><strong>Q11: How do you implement protected or private routes?</strong></p>
<p>Protected routes are routes that require authentication or authorization before allowing access. You create a wrapper component that checks the authentication status and either renders the child routes or redirects to a login page.</p>
<pre><code class="lang-jsx"><span class="xml">function ProtectedRoute({ children }) {
  const { user, loading } = useAuth();

  if (loading) return <span class="hljs-tag">&lt;<span class="hljs-name">LoadingSpinner</span> /&gt;</span>;

  if (!user) {
    return <span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">replace</span> /&gt;</span>;
  }

  return children;
}

// Usage with individual routes
<span class="hljs-tag">&lt;<span class="hljs-name">Route</span>
  <span class="hljs-attr">path</span>=<span class="hljs-string">"/dashboard"</span>
  <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>
    &lt;<span class="hljs-attr">ProtectedRoute</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Dashboard</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ProtectedRoute</span>&gt;</span>
  }
/&gt;

// Usage with nested routes using Outlet
function ProtectedLayout() {
  const { user, loading } = useAuth();

  if (loading) return <span class="hljs-tag">&lt;<span class="hljs-name">LoadingSpinner</span> /&gt;</span>;
  if (!user) return <span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">replace</span> /&gt;</span>;

  return <span class="hljs-tag">&lt;<span class="hljs-name">Outlet</span> /&gt;</span>;
}

<span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Login</span> /&gt;</span>} /&gt;
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">ProtectedLayout</span> /&gt;</span>}&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/dashboard"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Dashboard</span> /&gt;</span>} /&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/profile"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Profile</span> /&gt;</span>} /&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/settings"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">Settings</span> /&gt;</span>} /&gt;
  <span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span>
</code></pre>
<p>The second approach using a layout route is cleaner when you have many protected routes because you do not need to wrap each one individually.</p>
<hr>
<h2 id="dynamic-routing">DYNAMIC ROUTING</h2>
<p><strong>Q12: What is dynamic routing?</strong></p>
<p>Dynamic routing means defining routes with variable segments in the URL that can match different values. These variable segments are called URL parameters or route parameters. Instead of creating a separate route for every user or product, you define a single route pattern with a placeholder that matches any value in that position.</p>
<pre><code class="lang-jsx"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/users/:userId"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">UserProfile</span> /&gt;</span>} /&gt;
  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/products/:category/:productId"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">ProductDetail</span> /&gt;</span>} /&gt;
<span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span></span>
</code></pre>
<p>The colon prefix indicates a dynamic segment. <code>/users/1</code>, <code>/users/42</code>, and <code>/users/rahul</code> all match the first route. The matched value is accessible inside the component.</p>
<hr>
<p><strong>Q13: How do you access URL parameters in a component?</strong></p>
<p>You use the <code>useParams</code> hook which returns an object containing all the dynamic parameters from the current URL.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { useParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserProfile</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> { userId } = useParams();

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    fetchUser(userId).then(setUser);
  }, [userId]);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>User ID: {userId}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-comment">// URL: /users/42</span>
<span class="hljs-comment">// useParams() returns { userId: '42' }</span>
<span class="hljs-comment">// <span class="hljs-doctag">Note:</span> the value is always a string</span>
</code></pre>
<p>If you need the parameter as a number, you must convert it yourself using <code>Number(userId)</code> or <code>parseInt(userId, 10)</code>.</p>
<hr>
<p><strong>Q14: What are query parameters and how do you access them?</strong></p>
<p>Query parameters are key-value pairs appended to the URL after a question mark, like <code>/search?query=react&amp;page=2</code>. They are not defined in the route path. You access them using the <code>useSearchParams</code> hook.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { useSearchParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchPage</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [searchParams, setSearchParams] = useSearchParams();

  <span class="hljs-keyword">const</span> query = searchParams.get(<span class="hljs-string">'query'</span>);     <span class="hljs-comment">// 'react'</span>
  <span class="hljs-keyword">const</span> page = searchParams.get(<span class="hljs-string">'page'</span>);       <span class="hljs-comment">// '2'</span>

  <span class="hljs-keyword">const</span> handleNextPage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setSearchParams({ query, <span class="hljs-attr">page</span>: <span class="hljs-built_in">Number</span>(page) + <span class="hljs-number">1</span> });
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Searching for: {query}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Page: {page}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleNextPage}</span>&gt;</span>Next Page<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>The difference between URL parameters and query parameters is that URL parameters are part of the route definition and are required for matching. Query parameters are optional, not part of the route path, and are used for filtering, sorting, pagination, and other supplementary data.</p>
<hr>
<p><strong>Q15: How do you pass state through navigation?</strong></p>
<p>React Router allows you to pass state alongside navigation that does not appear in the URL. This is useful for sending data between routes without exposing it in the URL.</p>
<pre><code class="lang-jsx">// Sending <span class="hljs-keyword">state</span>
<span class="hljs-variable">&lt;Link to="/checkout" state={{ from: 'cart', items: cartItems }}&gt;</span>
  Checkout
&lt;/Link&gt;

// Or programmatically
navigate('/checkout', { <span class="hljs-keyword">state</span>: { <span class="hljs-keyword">from</span>: 'cart', items: cartItems } });

// Receiving <span class="hljs-keyword">state</span>
import { useLocation } <span class="hljs-keyword">from</span> 'react-router-dom';

function Checkout() {
  const location = useLocation();
  const { <span class="hljs-keyword">from</span>, items } = location.<span class="hljs-keyword">state</span> || {};

  return <span class="hljs-variable">&lt;p&gt;</span>Navigated <span class="hljs-keyword">from</span>: {<span class="hljs-keyword">from</span>}&lt;/p&gt;;
}
</code></pre>
<p>Be careful with navigation state because it does not persist if the user directly visits the URL or refreshes the page. Always provide a fallback.</p>
<hr>
<p><strong>Q16: What is the difference between <code>BrowserRouter</code> and <code>HashRouter</code>?</strong></p>
<p><code>BrowserRouter</code> uses the HTML5 History API to manage URLs. The URLs look clean like <code>/about</code> and <code>/users/42</code>. It requires server-side configuration to handle all routes by returning the <code>index.html</code> for any path, because if the user directly visits <code>/about</code>, the server needs to know to serve the React app instead of looking for an actual <code>/about</code> file.</p>
<p><code>HashRouter</code> uses the hash portion of the URL to manage routing. URLs look like <code>/#/about</code> and <code>/#/users/42</code>. Everything after the hash is never sent to the server, so no server configuration is needed. The server always serves the same page regardless of the hash.</p>
<p><code>BrowserRouter</code> is preferred for production applications because it produces cleaner URLs and is better for SEO. <code>HashRouter</code> is useful when you cannot configure the server, like when hosting on static file servers that do not support URL rewriting.</p>
<hr>
<h2 id="redux">REDUX</h2>
<p><strong>Q17: What is Redux?</strong></p>
<p>Redux is a predictable state management library for JavaScript applications, commonly used with React. It provides a centralized store that holds the entire application state in a single JavaScript object. Components can read data from this store and dispatch actions to update it. Redux follows three core principles: single source of truth where all state lives in one store, state is read-only where the only way to change state is by dispatching an action, and changes are made with pure functions called reducers.</p>
<hr>
<p><strong>Q18: Why do we need Redux when React already has state management?</strong></p>
<p>React&#39;s built-in state management with <code>useState</code> and <code>useContext</code> works well for many applications. However, as applications grow, several challenges arise. When many components across different parts of the tree need the same data, prop drilling becomes unwieldy and Context can cause performance issues with frequent updates. Complex state transitions with many interdependent actions become hard to manage with multiple <code>useState</code> calls. Debugging becomes difficult when state changes are scattered across many components.</p>
<p>Redux solves these by providing a single predictable store, a clear pattern for state updates through actions and reducers, excellent developer tools with time-travel debugging, middleware support for handling async operations, and a well-defined architecture that scales to large teams and codebases. However, Redux is not always necessary. For small to medium applications, React&#39;s built-in tools are often sufficient.</p>
<hr>
<p><strong>Q19: What are the core concepts of Redux?</strong></p>
<p>Redux has four core concepts. The <strong>Store</strong> is a single JavaScript object that holds the entire application state. There is only one store in a Redux application. <strong>Actions</strong> are plain JavaScript objects that describe what happened. Every action must have a <code>type</code> property and can optionally carry additional data called a payload. <strong>Reducers</strong> are pure functions that take the current state and an action, and return a new state. They specify how the state changes in response to each action type. <strong>Dispatch</strong> is the method used to send actions to the store, which triggers the reducer to compute the new state.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Action</span>
<span class="hljs-keyword">const</span> incrementAction = { <span class="hljs-keyword">type</span>: <span class="hljs-string">'INCREMENT'</span> };
<span class="hljs-keyword">const</span> addAction = { <span class="hljs-keyword">type</span>: <span class="hljs-string">'ADD'</span>, payload: <span class="hljs-number">5</span> };

<span class="hljs-comment">// Reducer</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counterReducer</span>(<span class="hljs-params">state = 0, action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>:
      <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'DECREMENT'</span>:
      <span class="hljs-keyword">return</span> state - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ADD'</span>:
      <span class="hljs-keyword">return</span> state + action.payload;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}

<span class="hljs-comment">// Store</span>
<span class="hljs-keyword">import</span> { createStore } from <span class="hljs-string">'redux'</span>;
<span class="hljs-keyword">const</span> store = createStore(counterReducer);

<span class="hljs-comment">// Dispatch</span>
store.dispatch({ <span class="hljs-keyword">type</span>: <span class="hljs-string">'INCREMENT'</span> });
store.dispatch({ <span class="hljs-keyword">type</span>: <span class="hljs-string">'ADD'</span>, payload: <span class="hljs-number">5</span> });
</code></pre>
<hr>
<p><strong>Q20: What is the Redux data flow?</strong></p>
<p>Redux follows a strict unidirectional data flow. First, the user interacts with the UI, like clicking a button. Second, the component dispatches an action describing what happened. Third, the store passes the current state and the action to the reducer. Fourth, the reducer computes and returns the new state. Fifth, the store saves the new state and notifies all subscribed components. Sixth, the subscribed components re-render with the updated data.</p>
<p>This cycle is always the same: UI triggers action, action goes to reducer, reducer returns new state, UI updates. This predictability makes debugging straightforward because you can trace every state change back to a specific action.</p>
<hr>
<p><strong>Q21: Why must reducers be pure functions?</strong></p>
<p>A pure function always returns the same output for the same inputs and produces no side effects. Reducers must be pure for several reasons. Predictability means that given the same state and action, you always get the same result, making the app behavior deterministic. Testing is simple because you just pass inputs and assert outputs. Time-travel debugging in Redux DevTools works by replaying actions through reducers, which only works if reducers produce consistent results. React&#39;s rendering optimization depends on detecting state changes by comparing references, and pure functions that return new objects make this comparison reliable.</p>
<p>Things a reducer must never do include mutating the existing state, making API calls, calling <code>Math.random()</code> or <code>Date.now()</code>, or performing any side effect.</p>
<pre><code class="lang-jsx">// ‚ùå Impure ‚Äî mutates <span class="hljs-keyword">state</span>
function reducer(<span class="hljs-keyword">state</span>, action) {
  <span class="hljs-keyword">state</span>.count = <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span>; // Mutation!
  return <span class="hljs-keyword">state</span>; // Same reference, Redux won't detect change
}

// ‚úÖ Pure ‚Äî returns new object
function reducer(<span class="hljs-keyword">state</span>, action) {
  return { ...<span class="hljs-keyword">state</span>, count: <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span> }; // New reference
}
</code></pre>
<hr>
<p><strong>Q22: How do you connect Redux to React components?</strong></p>
<p>In modern React-Redux, you use hooks. <code>useSelector</code> reads data from the store, and <code>useDispatch</code> returns the dispatch function to send actions. The entire app is wrapped in a <code>Provider</code> component that makes the store available to all components.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { Provider, useSelector, useDispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> { configureStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@reduxjs/toolkit'</span>;

<span class="hljs-comment">// Wrap the app</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">store</span>=<span class="hljs-string">{store}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// Use in any component</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> count = useSelector(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.counter.value);
  <span class="hljs-keyword">const</span> dispatch = useDispatch();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'INCREMENT' })}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<hr>
<p><strong>Q23: What is the difference between <code>useSelector</code> and <code>useContext</code> for accessing state?</strong></p>
<p><code>useSelector</code> subscribes to the Redux store and re-renders the component only when the specific selected value changes. It uses strict equality comparison by default so it can skip re-renders when unrelated parts of the store change. <code>useContext</code> re-renders the component whenever any part of the context value changes, even if the component only uses a small portion of that value.</p>
<p>This makes <code>useSelector</code> more performant for frequent state updates because it provides fine-grained subscriptions. Context re-renders all consumers on any change, while Redux re-renders only the components whose selected data actually changed.</p>
<hr>
<h2 id="redux-toolkit">REDUX TOOLKIT</h2>
<p><strong>Q24: What is Redux Toolkit and why was it created?</strong></p>
<p>Redux Toolkit is the official, recommended way to write Redux logic. It was created because traditional Redux had three major complaints. Too much boilerplate code was required with separate files for action types, action creators, and reducers. Configuring the store required many packages and manual setup for middleware, DevTools, and other enhancers. Too many additional packages were needed for common tasks like immutable updates, async logic, and entity management.</p>
<p>Redux Toolkit simplifies all of this by providing utility functions that handle the most common Redux patterns with less code while following best practices by default.</p>
<hr>
<p><strong>Q25: What are the key APIs in Redux Toolkit?</strong></p>
<p>The key APIs are <code>configureStore</code> which sets up the store with good defaults including Redux DevTools and the thunk middleware automatically. <code>createSlice</code> which generates action creators and action types automatically from reducer functions and is the most commonly used API. <code>createAsyncThunk</code> which generates thunks for async operations like API calls. <code>createEntityAdapter</code> which provides reusable reducers and selectors for managing normalized data in the store.</p>
<hr>
<p><strong>Q26: What is a slice in Redux Toolkit?</strong></p>
<p>A slice is a collection of Redux reducer logic and actions for a single feature of your application. <code>createSlice</code> accepts an initial state, an object of reducer functions, and a slice name, and it automatically generates action creators and action type strings that correspond to the reducers.</p>
<pre><code class="lang-jsx">import { createSlice } <span class="hljs-keyword">from</span> '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: <span class="hljs-number">0</span> },
  reducers: {
    increment: (<span class="hljs-keyword">state</span>) =&gt; {
      <span class="hljs-keyword">state</span>.value += <span class="hljs-number">1</span>; // <span class="hljs-string">"Mutating"</span> syntax is okay here ‚Äî explained below
    },
    decrement: (<span class="hljs-keyword">state</span>) =&gt; {
      <span class="hljs-keyword">state</span>.value -= <span class="hljs-number">1</span>;
    },
    incrementByAmount: (<span class="hljs-keyword">state</span>, action) =&gt; {
      <span class="hljs-keyword">state</span>.value += action.payload;
    },
    reset: (<span class="hljs-keyword">state</span>) =&gt; {
      <span class="hljs-keyword">state</span>.value = <span class="hljs-number">0</span>;
    }
  }
});

// Auto-generated action creators
export const { increment, decrement, incrementByAmount, reset } = counterSlice.actions;

// Reducer <span class="hljs-keyword">to</span> be added <span class="hljs-keyword">to</span> the store
export <span class="hljs-keyword">default</span> counterSlice.reducer;
</code></pre>
<p>Without Redux Toolkit, this same functionality would require separate files for action type constants, action creator functions, and a reducer with a switch statement. <code>createSlice</code> collapses all of that into one concise definition.</p>
<hr>
<p><strong>Q27: Why can you write &quot;mutating&quot; code inside <code>createSlice</code> reducers when Redux requires immutability?</strong></p>
<p>Redux Toolkit uses a library called Immer under the hood. When you write code that appears to mutate state inside a <code>createSlice</code> reducer, Immer intercepts those mutations and produces a new immutable state object behind the scenes. You are not actually mutating the state. Immer creates a draft copy, applies your changes to the draft, and then produces a new immutable result.</p>
<p>This means both styles work inside <code>createSlice</code>:</p>
<pre><code class="lang-jsx">// Style <span class="hljs-number">1</span>: <span class="hljs-string">"Mutating"</span> syntax ‚Äî Immer handles immutability
increment: (<span class="hljs-keyword">state</span>) =&gt; {
  <span class="hljs-keyword">state</span>.value += <span class="hljs-number">1</span>;
}

// Style <span class="hljs-number">2</span>: Traditional immutable return ‚Äî also works
increment: (<span class="hljs-keyword">state</span>) =&gt; {
  return { ...<span class="hljs-keyword">state</span>, value: <span class="hljs-keyword">state</span>.value + <span class="hljs-number">1</span> };
}
</code></pre>
<p>The mutating syntax is preferred because it is more readable, especially for deeply nested state updates. However, this only works inside <code>createSlice</code> and <code>createReducer</code>. You must never mutate state in plain Redux reducers outside of Redux Toolkit.</p>
<hr>
<p><strong>Q28: How do you set up a Redux Toolkit store?</strong></p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { configureStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@reduxjs/toolkit'</span>;
<span class="hljs-keyword">import</span> counterReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./features/counterSlice'</span>;
<span class="hljs-keyword">import</span> userReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./features/userSlice'</span>;
<span class="hljs-keyword">import</span> cartReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./features/cartSlice'</span>;

<span class="hljs-keyword">const</span> store = configureStore({
  <span class="hljs-attr">reducer</span>: {
    <span class="hljs-attr">counter</span>: counterReducer,
    <span class="hljs-attr">user</span>: userReducer,
    <span class="hljs-attr">cart</span>: cartReducer,
  }
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;
</code></pre>
<p><code>configureStore</code> automatically sets up the Redux DevTools extension, adds the <code>redux-thunk</code> middleware for async operations, adds development-only middleware that checks for common mistakes like state mutation and non-serializable values, and combines all the slice reducers into a root reducer. In traditional Redux, you would need to manually configure each of these features.</p>
<hr>
<p><strong>Q29: How do you use Redux Toolkit state in a component?</strong></p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { useSelector, useDispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> { increment, decrement, incrementByAmount, reset } <span class="hljs-keyword">from</span> <span class="hljs-string">'./counterSlice'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> count = useSelector(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.counter.value);
  <span class="hljs-keyword">const</span> dispatch = useDispatch();

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch(increment())}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch(decrement())}&gt;-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch(incrementByAmount(5))}&gt;+5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch(reset())}&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>Notice that the action creators like <code>increment()</code> are called as functions. They return action objects like <code>{ type: &#39;counter/increment&#39; }</code>. The type string is automatically generated from the slice name and the reducer function name.</p>
<hr>
<p><strong>Q30: What is the difference between traditional Redux and Redux Toolkit?</strong></p>
<p>Traditional Redux requires you to manually define action type constants as strings, write separate action creator functions, write reducers with switch statements, manually configure the store with middleware and DevTools, and manually handle immutable updates using the spread operator for every nested level. Redux Toolkit eliminates all of this boilerplate. <code>createSlice</code> generates action types and creators automatically. Reducers use simple function definitions instead of switch statements. <code>configureStore</code> handles all store setup automatically. Immer handles immutability so you can write simpler update logic. The result is roughly 50 to 75 percent less code with the same functionality and fewer opportunities for bugs.</p>
<hr>
<h2 id="middleware-redux-thunk-saga-">MIDDLEWARE (REDUX THUNK / SAGA)</h2>
<p><strong>Q31: What is middleware in Redux?</strong></p>
<p>Middleware is code that runs between the moment an action is dispatched and the moment it reaches the reducer. It intercepts actions and can transform them, delay them, replace them, or perform side effects before the action reaches the reducer. Middleware is the recommended place for side effects like API calls, logging, analytics, and routing in a Redux application.</p>
<p>The flow with middleware is: Component dispatches action ‚Üí Middleware intercepts ‚Üí Middleware does its work ‚Üí Action reaches reducer ‚Üí State updates ‚Üí UI re-renders.</p>
<hr>
<p><strong>Q32: Why is middleware needed? Why not just put async logic in components?</strong></p>
<p>You could put async logic in components, but middleware provides several advantages. It keeps components clean and focused on rendering, with no API call logic mixed in. The async logic becomes reusable across multiple components. It is easier to test because middleware logic is separate from component rendering. It centralizes side effect handling in one predictable location. Error handling for async operations can be managed consistently. The Redux DevTools can track the entire flow including pending, fulfilled, and rejected states.</p>
<hr>
<p><strong>Q33: What is Redux Thunk?</strong></p>
<p>Redux Thunk is a middleware that allows you to write action creators that return functions instead of plain action objects. These functions receive <code>dispatch</code> and <code>getState</code> as arguments, allowing you to perform async operations and dispatch multiple actions over time.</p>
<p>Without thunk, action creators can only return plain objects which must be synchronous. With thunk, an action creator can return a function that performs async work like API calls and dispatches actions at different stages of that work.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Without Thunk ‚Äî can only return objects (synchronous)</span>
<span class="hljs-keyword">const</span> increment = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> });

<span class="hljs-comment">// With Thunk ‚Äî can return a function (asynchronous)</span>
<span class="hljs-keyword">const</span> fetchUser = <span class="hljs-function">(<span class="hljs-params">userId</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> (dispatch, getState) =&gt; {
    dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_USER_PENDING'</span> });

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>);
      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();
      dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_USER_FULFILLED'</span>, <span class="hljs-attr">payload</span>: data });
    } <span class="hljs-keyword">catch</span> (error) {
      dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_USER_REJECTED'</span>, <span class="hljs-attr">payload</span>: error.message });
    }
  };
};

<span class="hljs-comment">// Usage in component</span>
dispatch(fetchUser(<span class="hljs-number">42</span>));
</code></pre>
<p>Redux Thunk is included by default in Redux Toolkit&#39;s <code>configureStore</code>, so you do not need to install or configure it separately.</p>
<hr>
<p><strong>Q34: What is <code>createAsyncThunk</code> in Redux Toolkit?</strong></p>
<p><code>createAsyncThunk</code> is a Redux Toolkit utility that simplifies the common pattern of dispatching pending, fulfilled, and rejected actions for async operations. You provide a string action type prefix and an async function, and it automatically generates three action types and dispatches them at the appropriate times.</p>
<pre><code class="lang-jsx">import { createSlice, createAsyncThunk } <span class="hljs-keyword">from</span> '@reduxjs/toolkit';

// Define the async thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',          // Action type prefix
  async (_, { rejectWithValue }) =&gt; {
    try {
      const response = await fetch('/api/users');
      if (!response.ok) throw new Error('Failed <span class="hljs-keyword">to</span> fetch');
      return await response.json();  // This becomes action.payload <span class="hljs-keyword">in</span> fulfilled
    } catch (error) {
      return rejectWithValue(error.message); // This becomes action.payload <span class="hljs-keyword">in</span> rejected
    }
  }
);

// Handle <span class="hljs-keyword">in</span> the slice
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    data: [],
    loading: false,
    error: null
  },
  reducers: {},
  extraReducers: (builder) =&gt; {
    builder
      .addCase(fetchUsers.pending, (<span class="hljs-keyword">state</span>) =&gt; {
        <span class="hljs-keyword">state</span>.loading = true;
        <span class="hljs-keyword">state</span>.error = null;
      })
      .addCase(fetchUsers.fulfilled, (<span class="hljs-keyword">state</span>, action) =&gt; {
        <span class="hljs-keyword">state</span>.loading = false;
        <span class="hljs-keyword">state</span>.data = action.payload;
      })
      .addCase(fetchUsers.rejected, (<span class="hljs-keyword">state</span>, action) =&gt; {
        <span class="hljs-keyword">state</span>.loading = false;
        <span class="hljs-keyword">state</span>.error = action.payload;
      });
  }
});
</code></pre>
<p><code>createAsyncThunk</code> automatically generates three action types: <code>users/fetchUsers/pending</code>, <code>users/fetchUsers/fulfilled</code>, and <code>users/fetchUsers/rejected</code>. The <code>extraReducers</code> field handles actions that are not defined in the slice&#39;s own <code>reducers</code> field, such as actions from thunks or from other slices.</p>
<hr>
<p><strong>Q35: How do you use <code>createAsyncThunk</code> in a component?</strong></p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useSelector, useDispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;
<span class="hljs-keyword">import</span> { fetchUsers } <span class="hljs-keyword">from</span> <span class="hljs-string">'./usersSlice'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserList</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> dispatch = useDispatch();
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: users, loading, error } = useSelector(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.users);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    dispatch(fetchUsers());
  }, [dispatch]);

  <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Error: {error}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      {users.map(user =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
}
</code></pre>
<hr>
<p><strong>Q36: What is <code>extraReducers</code> and how is it different from <code>reducers</code> in <code>createSlice</code>?</strong></p>
<p>The <code>reducers</code> field in <code>createSlice</code> defines reducer functions that automatically generate corresponding action creators. These are for synchronous actions that belong to this slice. The <code>extraReducers</code> field allows the slice to respond to actions defined outside the slice, such as actions from <code>createAsyncThunk</code> or actions from other slices. It does not generate any action creators. It only adds additional case handlers to the reducer.</p>
<p>Think of <code>reducers</code> as actions this slice owns and <code>extraReducers</code> as actions this slice listens to but does not own.</p>
<hr>
<p><strong>Q37: What is Redux Saga?</strong></p>
<p>Redux Saga is an alternative middleware to Redux Thunk for handling side effects. Instead of using async/await and thunks, Saga uses ES6 generator functions to make async flows look synchronous and easier to test. Sagas are like separate threads in your application that are solely responsible for side effects.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { call, put, takeEvery } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-saga/effects'</span>;

<span class="hljs-comment">// Worker Saga</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fetchUserSaga</span>(<span class="hljs-params">action</span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> put({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_USER_PENDING'</span> });
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">yield</span> call(fetch, <span class="hljs-string">`/api/users/<span class="hljs-subst">${action.payload}</span>`</span>);
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">yield</span> call([user, user.json]);
    <span class="hljs-keyword">yield</span> put({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_USER_FULFILLED'</span>, <span class="hljs-attr">payload</span>: data });
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-keyword">yield</span> put({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_USER_REJECTED'</span>, <span class="hljs-attr">payload</span>: error.message });
  }
}

<span class="hljs-comment">// Watcher Saga</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">watchFetchUser</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> takeEvery(<span class="hljs-string">'FETCH_USER_REQUESTED'</span>, fetchUserSaga);
}
</code></pre>
<p>Key Saga effects include <code>call</code> for calling async functions, <code>put</code> for dispatching actions, <code>takeEvery</code> for listening to every occurrence of an action, <code>takeLatest</code> for only handling the most recent occurrence and canceling previous ones, and <code>all</code> for running multiple sagas in parallel.</p>
<hr>
<p><strong>Q38: What is the difference between Redux Thunk and Redux Saga?</strong></p>
<p>Redux Thunk uses regular functions and async/await syntax. It is simpler to learn and set up and is sufficient for most applications. It handles straightforward async operations well but can become messy for complex flows like debouncing, retrying, racing conditions, or cancellation.</p>
<p>Redux Saga uses generator functions and a more structured approach. It has a steeper learning curve but excels at complex async scenarios. It provides built-in support for cancellation, debouncing, throttling, race conditions, and parallel execution. Testing is easier because Saga effects are plain objects that can be compared without mocking.</p>
<p>For most applications, Redux Thunk with <code>createAsyncThunk</code> from Redux Toolkit is sufficient and recommended. Redux Saga is better suited for applications with very complex async workflows like real-time data streams, complex orchestration between multiple API calls, or scenarios where cancellation and retry logic are critical.</p>
<hr>
<p><strong>Q39: Can you use Redux Toolkit with Redux Saga?</strong></p>
<p>Yes. Redux Toolkit is agnostic about which middleware you use. You can replace or add alongside the default thunk middleware when configuring the store.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> createSagaMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">'redux-saga'</span>;
<span class="hljs-keyword">import</span> { configureStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@reduxjs/toolkit'</span>;
<span class="hljs-keyword">import</span> rootSaga <span class="hljs-keyword">from</span> <span class="hljs-string">'./sagas'</span>;

<span class="hljs-keyword">const</span> sagaMiddleware = createSagaMiddleware();

<span class="hljs-keyword">const</span> store = configureStore({
  <span class="hljs-attr">reducer</span>: rootReducer,
  <span class="hljs-attr">middleware</span>: <span class="hljs-function">(<span class="hljs-params">getDefaultMiddleware</span>) =&gt;</span>
    getDefaultMiddleware({ <span class="hljs-attr">thunk</span>: <span class="hljs-literal">false</span> }).concat(sagaMiddleware),
});

sagaMiddleware.run(rootSaga);
</code></pre>
<p>You can even use both Thunk and Saga together if needed, though this is uncommon and usually unnecessary.</p>
<hr>
<h2 id="bonus-routing-state-management-questions">BONUS ROUTING &amp; STATE MANAGEMENT QUESTIONS</h2>
<p><strong>Q40: How do you handle route-based code splitting?</strong></p>
<p>You combine React Router with React&#39;s <code>lazy</code> and <code>Suspense</code> to load route components only when the user navigates to them, reducing the initial bundle size.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { lazy, Suspense } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { BrowserRouter, Routes, Route } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">const</span> Home = lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./pages/Home'</span>));
<span class="hljs-keyword">const</span> About = lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./pages/About'</span>));
<span class="hljs-keyword">const</span> Dashboard = lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./pages/Dashboard'</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    &lt;BrowserRouter&gt;
      &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
          &lt;Route path="/dashboard" element={&lt;Dashboard /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/Suspense&gt;
    &lt;/BrowserRouter&gt;
  );
}
</code></pre>
<p>Each page component is bundled separately and only downloaded when the user visits that route.</p>
<hr>
<p><strong>Q41: What is the <code>useLocation</code> hook?</strong></p>
<p><code>useLocation</code> returns the current location object which contains the pathname, search string, hash, state, and key. It is useful for tracking the current route, reading query parameters, accessing navigation state, or performing actions when the route changes.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { useLocation } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Analytics</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> location = useLocation();

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    trackPageView(location.pathname);
  }, [location]);

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<hr>
<p><strong>Q42: What is Redux DevTools and why is it important?</strong></p>
<p>Redux DevTools is a browser extension that provides powerful debugging capabilities for Redux applications. It shows every action that was dispatched along with its type and payload. It shows the state before and after each action. It supports time-travel debugging where you can jump to any previous state by clicking on a past action. You can replay actions, export and import state, and skip or replay specific actions. This level of visibility into state changes is one of Redux&#39;s biggest advantages and is one reason teams choose Redux over simpler state management solutions for complex applications.</p>
<hr>
<p><strong>Q43: What are selectors in Redux and why are they useful?</strong></p>
<p>Selectors are functions that extract specific pieces of data from the Redux store. They centralize the logic for reading from the store, making it reusable and easy to change if the state structure changes. Memoized selectors created with libraries like Reselect avoid unnecessary recalculations when unrelated state changes.</p>
<pre><code class="lang-jsx">// Basic selectors
const selectUsers = (<span class="hljs-keyword">state</span>) =&gt; <span class="hljs-keyword">state</span>.users.data;
const selectLoading = (<span class="hljs-keyword">state</span>) =&gt; <span class="hljs-keyword">state</span>.users.loading;

// Derived/computed selector
const selectActiveUsers = (<span class="hljs-keyword">state</span>) =&gt;
  <span class="hljs-keyword">state</span>.users.data.filter(<span class="hljs-keyword">user</span> =&gt; <span class="hljs-keyword">user</span>.isActive);

// Using <span class="hljs-keyword">in</span> component
const activeUsers = useSelector(selectActiveUsers);
</code></pre>
<p>Without selectors, every component would inline the state access logic. If the state shape changes, you would need to update every component. With selectors, you update the selector once and all components automatically get the correct data.</p>
<hr>
<p><strong>Q44: When should you keep state in Redux versus local component state?</strong></p>
<p>State should go in Redux when multiple components across different parts of the tree need to access it, when the state needs to persist across route changes, when the state is modified by many different actions, or when you need to track changes with DevTools. State should stay local in a component when only that component or its direct children need it, when the state is temporary UI state like whether a dropdown is open or a form input value, when the state resets when the component unmounts, or when putting it in Redux would add unnecessary complexity. A good rule of thumb is to ask whether other parts of the application care about this data. If yes, it belongs in a shared store. If no, keep it local.</p>
<hr>
<h1 id="-performance-optimization-interview-q-a">üîπ Performance &amp; Optimization ‚Äî Interview Q&amp;A</h1>
<hr>
<h2 id="memoization">MEMOIZATION</h2>
<p><strong>Q1: What is memoization in the context of React?</strong></p>
<p>Memoization is an optimization technique where you cache the result of an expensive computation and return the cached result when the same inputs occur again, instead of recalculating. In React, memoization is used at three levels. You can memoize computed values using <code>useMemo</code> so that expensive calculations do not re-run on every render. You can memoize function references using <code>useCallback</code> so that the same function instance is reused across renders. You can memoize entire components using <code>React.memo</code> so that a component skips re-rendering when its props have not changed. The fundamental idea is the same across all three ‚Äî avoid doing work that has already been done when nothing relevant has changed.</p>
<hr>
<p><strong>Q2: Why is memoization important in React?</strong></p>
<p>Every time a component re-renders, the entire function body executes from top to bottom. Every variable is recalculated, every function is recreated, and every object and array is allocated fresh in memory. For simple operations this is trivially fast, but for expensive computations, large list transformations, or deeply nested component trees, unnecessary recalculations and re-renders can cause visible performance degradation. Memoization lets you skip this redundant work by saying &quot;if the inputs have not changed, use the previous result.&quot;</p>
<hr>
<p><strong>Q3: What are the different memoization tools React provides?</strong></p>
<p>React provides three built-in memoization tools. <code>React.memo</code> is a higher-order component that wraps a functional component and prevents it from re-rendering if its props have not changed. <code>useMemo</code> is a hook that caches the return value of a function and only recalculates when its dependencies change. <code>useCallback</code> is a hook that caches a function definition itself and only creates a new function when its dependencies change. Each serves a different purpose but they all follow the same principle of comparing current inputs with previous inputs and skipping unnecessary work.</p>
<hr>
<p><strong>Q4: When should you NOT use memoization?</strong></p>
<p>Memoization is not free. It has its own costs including storing the previous value in memory, comparing dependencies on every render, and adding complexity to the code. You should avoid memoization when the computation is trivially cheap like simple arithmetic, string concatenation, or accessing a property. You should avoid it when the component is already fast and there is no measurable performance problem. You should avoid it when the dependencies change on almost every render because the memoization check runs but always recalculates anyway, making it slower than not memoizing at all. You should avoid premature optimization. The React documentation recommends profiling first to identify actual bottlenecks and then applying memoization where it measurably helps rather than sprinkling it everywhere preventively.</p>
<hr>
<h2 id="react-memo">REACT.MEMO</h2>
<p><strong>Q5: What is <code>React.memo</code>?</strong></p>
<p><code>React.memo</code> is a higher-order component that memoizes a functional component. It wraps a component and performs a shallow comparison of its props before re-rendering. If the props have not changed since the last render, React skips rendering that component and reuses the previous result. It is the functional component equivalent of <code>PureComponent</code> in class components.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> ExpensiveList = React.memo(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ExpensiveList</span>(<span class="hljs-params">{ items, onItemClick }</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ExpensiveList rendered'</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      {items.map(item =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> onItemClick(item.id)}&gt;
          {item.name}
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
});
</code></pre>
<p>Now <code>ExpensiveList</code> will only re-render if <code>items</code> or <code>onItemClick</code> actually change by reference.</p>
<hr>
<p><strong>Q6: What does &quot;shallow comparison&quot; mean in the context of <code>React.memo</code>?</strong></p>
<p>Shallow comparison means React compares props at the top level only using <code>Object.is</code> comparison. For primitive values like strings, numbers, and booleans, it checks if the values are the same. For objects, arrays, and functions, it checks if the references are the same, not whether the contents are identical. This means if a parent creates a new object or array with the same contents on every render, the shallow comparison fails because the reference is different, and the memoized component re-renders despite the data being identical.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// ‚ùå New object reference on every render ‚Äî defeats React.memo</span>
  <span class="hljs-keyword">const</span> style = { <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span> };

  <span class="hljs-comment">// ‚ùå New array reference on every render ‚Äî defeats React.memo</span>
  <span class="hljs-keyword">const</span> items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

  <span class="hljs-comment">// ‚ùå New function reference on every render ‚Äî defeats React.memo</span>
  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'clicked'</span>);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MemoizedChild</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span> /&gt;</span>;
}</span>
</code></pre>
<p>To make <code>React.memo</code> effective with objects, arrays, and functions, you need to stabilize their references using <code>useMemo</code> and <code>useCallback</code>.</p>
<hr>
<p><strong>Q7: How do you make <code>React.memo</code> work properly with object and function props?</strong></p>
<p>You stabilize references using <code>useMemo</code> for objects and arrays and <code>useCallback</code> for functions:</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span></span> Parent() {
  const [<span class="hljs-built_in">count</span>, setCount] = useState(<span class="hljs-number">0</span>);
  const [text, setText] = useState(<span class="hljs-string">''</span>);

  // ‚úÖ Stable object reference ‚Äî <span class="hljs-keyword">only</span> changes when <span class="hljs-built_in">count</span> changes
  const <span class="hljs-keyword">data</span> = useMemo(() =&gt; ({ <span class="hljs-keyword">value</span>: <span class="hljs-built_in">count</span> }), [<span class="hljs-built_in">count</span>]);

  // ‚úÖ Stable <span class="hljs-function"><span class="hljs-keyword">function</span></span> reference ‚Äî never changes
  const handleClick = useCallback(() =&gt; {
    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'clicked'</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;input <span class="hljs-keyword">value</span>={text} onChange={e =&gt; setText(e.<span class="hljs-keyword">target</span>.<span class="hljs-keyword">value</span>)} /&gt;
      &lt;MemoizedChild <span class="hljs-keyword">data</span>={<span class="hljs-keyword">data</span>} onClick={handleClick} /&gt;
    &lt;/div&gt;
  );
}

const MemoizedChild = React.memo(({ <span class="hljs-keyword">data</span>, onClick }) =&gt; {
  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'Child rendered'</span>);
  <span class="hljs-keyword">return</span> &lt;button onClick={onClick}&gt;{<span class="hljs-keyword">data</span>.<span class="hljs-keyword">value</span>}&lt;/button&gt;;
});
</code></pre>
<p>Now when the user types in the input, <code>Parent</code> re-renders but <code>MemoizedChild</code> does not because neither <code>data</code> nor <code>handleClick</code> have changed their references. Without <code>useMemo</code> and <code>useCallback</code>, the child would re-render on every keystroke even though the data it displays has not changed.</p>
<hr>
<p><strong>Q8: Can you provide a custom comparison function to <code>React.memo</code>?</strong></p>
<p>Yes. <code>React.memo</code> accepts an optional second argument which is a custom comparison function. This function receives the previous props and the next props and returns <code>true</code> if the component should skip re-rendering or <code>false</code> if it should re-render.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> UserCard = React.memo(
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserCard</span>(<span class="hljs-params">{ user, theme }</span>) </span>{
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{theme}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{user.email}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  },
  (prevProps, nextProps) =&gt; {
    <span class="hljs-comment">// Only re-render if user.id or theme changes</span>
    <span class="hljs-comment">// Return true to SKIP re-render, false to ALLOW re-render</span>
    <span class="hljs-keyword">return</span> (
      prevProps.user.id === nextProps.user.id &amp;&amp;
      prevProps.theme === nextProps.theme
    );
  }
);
</code></pre>
<p>This is useful when the default shallow comparison is not sufficient, such as when you want to compare only certain properties of an object prop or perform a deep comparison on specific fields. However, use custom comparators carefully because returning incorrect results can cause stale UI where the component does not update when it should.</p>
<hr>
<p><strong>Q9: What is the difference between <code>React.memo</code> and <code>useMemo</code>?</strong></p>
<p><code>React.memo</code> memoizes an entire component. It prevents the component from re-rendering when its props have not changed. It wraps the component definition at the module level. <code>useMemo</code> memoizes a computed value inside a component. It prevents a specific calculation from re-running when its dependencies have not changed. It is called inside the component body.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// React.memo ‚Äî memoizes the component itself</span>
<span class="hljs-keyword">const</span> MemoizedList = React.memo(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span><span class="hljs-params">({ items })</span> </span>{
  <span class="hljs-keyword">return</span> items.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;);
});

<span class="hljs-comment">// useMemo ‚Äî memoizes a value inside a component</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span><span class="hljs-params">({ items, query })</span> </span>{
  <span class="hljs-keyword">const</span> filteredItems = useMemo(() =&gt; {
    <span class="hljs-keyword">return</span> items.filter(item =&gt; item.name.includes(query));
  }, [items, query]);

  <span class="hljs-keyword">return</span> filteredItems.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;);
}
</code></pre>
<p>They serve complementary purposes. <code>React.memo</code> prevents the component from running at all. <code>useMemo</code> prevents expensive work inside the component from running unnecessarily.</p>
<hr>
<p><strong>Q10: What is the difference between <code>React.memo</code> and <code>PureComponent</code>?</strong></p>
<p>Both serve the same purpose of preventing unnecessary re-renders through shallow prop comparison. <code>PureComponent</code> is for class components. It extends <code>React.Component</code> and implements <code>shouldComponentUpdate</code> with a shallow comparison of both props and state. <code>React.memo</code> is for functional components. It only compares props since functional components manage state through hooks which already trigger re-renders only when the state value actually changes. If you are migrating a class component that extends <code>PureComponent</code> to a functional component, wrapping it with <code>React.memo</code> achieves equivalent behavior.</p>
<hr>
<p><strong>Q11: Does <code>React.memo</code> prevent re-renders caused by context changes?</strong></p>
<p>No. If a memoized component consumes a context using <code>useContext</code> and that context value changes, the component will re-render regardless of whether its props changed. <code>React.memo</code> only checks props. Context updates bypass the memo optimization entirely. This is a common pitfall where developers wrap a component in <code>React.memo</code> expecting it to prevent re-renders but the component still re-renders because it subscribes to a frequently changing context.</p>
<hr>
<h2 id="lazy-loading">LAZY LOADING</h2>
<p><strong>Q12: What is lazy loading in React?</strong></p>
<p>Lazy loading is a technique where you defer loading a component or resource until it is actually needed. Instead of including everything in the initial JavaScript bundle that the user downloads on the first page load, you split the application into smaller chunks and load them on demand. This reduces the initial bundle size and improves the time to first meaningful render because the user only downloads the code they need for the current view.</p>
<hr>
<p><strong>Q13: How do you implement lazy loading in React?</strong></p>
<p>React provides the <code>React.lazy</code> function which lets you dynamically import a component. The component is loaded only when it is first rendered. <code>React.lazy</code> takes a function that must call a dynamic <code>import()</code> and returns a Promise that resolves to a module with a default export containing a React component.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { lazy } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-comment">// Instead of regular import</span>
<span class="hljs-comment">// import HeavyChart from './HeavyChart';</span>

<span class="hljs-comment">// Lazy import ‚Äî loaded only when rendered</span>
<span class="hljs-keyword">const</span> HeavyChart = lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./HeavyChart'</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dashboard</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [showChart, setShowChart] = useState(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setShowChart(true)}&gt;Show Chart<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      {showChart &amp;&amp; <span class="hljs-tag">&lt;<span class="hljs-name">HeavyChart</span> /&gt;</span>}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>In this example, the <code>HeavyChart</code> component&#39;s code is not included in the initial bundle. It is downloaded as a separate chunk only when the user clicks the button and <code>showChart</code> becomes true. This is especially useful for heavy components that include large libraries like charting or mapping libraries.</p>
<hr>
<p><strong>Q14: What are the requirements and limitations of <code>React.lazy</code>?</strong></p>
<p><code>React.lazy</code> currently only supports default exports. If the module uses named exports, you need an intermediate module that re-exports it as default, or you can use an inline wrapper. The lazy component must be rendered inside a <code>Suspense</code> component that provides a fallback UI while the component is loading. <code>React.lazy</code> only works with client-side rendering. For server-side rendering, you need libraries like <code>loadable-components</code>. Also, <code>React.lazy</code> cannot be used for regular functions or non-component modules. It is specifically for React component dynamic imports.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// If the module uses named exports</span>
<span class="hljs-keyword">const</span> MyComponent = lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  <span class="hljs-keyword">import</span>(<span class="hljs-string">'./MyModule'</span>).then(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> ({ <span class="hljs-attr">default</span>: <span class="hljs-built_in">module</span>.MyComponent }))
);
</code></pre>
<hr>
<p><strong>Q15: What are common use cases for lazy loading?</strong></p>
<p>Route-based lazy loading is the most common where each page or route is a separate lazy-loaded chunk so users only download the code for the page they visit. Feature-based lazy loading is useful for heavy features like rich text editors, charting libraries, or admin panels that not every user needs. Conditional lazy loading works well for components shown based on user interaction like modals, dropdowns, or expandable sections. Below-the-fold content that is not visible on the initial viewport can be lazy loaded to prioritize content the user sees first.</p>
<hr>
<h2 id="suspense">SUSPENSE</h2>
<p><strong>Q16: What is <code>Suspense</code> in React?</strong></p>
<p><code>Suspense</code> is a React component that lets you declaratively specify a loading state for a part of the component tree while its children are not yet ready to render. It wraps components that might need to wait for something, like a lazily loaded component or in newer versions data that is being fetched. While waiting, it displays a fallback UI that you provide.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { Suspense, lazy } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> HeavyDashboard = lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./HeavyDashboard'</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">div</span>&gt;</span>Loading dashboard...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">HeavyDashboard</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
  );
}
</code></pre>
<p>When <code>HeavyDashboard</code> is being downloaded, the user sees &quot;Loading dashboard...&quot; and once the download completes, the actual component renders.</p>
<hr>
<p><strong>Q17: Can you have multiple or nested <code>Suspense</code> boundaries?</strong></p>
<p>Yes, and this is a powerful pattern. You can nest <code>Suspense</code> boundaries at different levels of your component tree to provide granular loading states. Without nesting, a single <code>Suspense</code> at the top would show one big loading spinner for the entire app. With nested boundaries, different sections can load independently and show their own loading indicators.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">FullPageSpinner</span> /&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">SidebarSkeleton</span> /&gt;</span>}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">Sidebar</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">ContentSkeleton</span> /&gt;</span>}&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
  );
}
</code></pre>
<p>In this example, the header loads first. If the sidebar takes longer, its own skeleton is shown without affecting the header. The main content has its own independent loading state. If any component fails to load, only the nearest <code>Suspense</code> boundary is affected, not the entire page.</p>
<hr>
<p><strong>Q18: What happens if there is no <code>Suspense</code> boundary above a lazy component?</strong></p>
<p>React will throw an error. Every component loaded with <code>React.lazy</code> must have a <code>Suspense</code> ancestor somewhere above it in the component tree. If React encounters a lazy component that suspends and there is no <code>Suspense</code> boundary to catch it, the error will propagate up and either be caught by an Error Boundary or crash the application. This is similar to how throwing an error without a try-catch causes a crash.</p>
<hr>
<p><strong>Q19: What is the difference between <code>Suspense</code> and Error Boundaries?</strong></p>
<p><code>Suspense</code> handles the loading state. It shows a fallback while a component is waiting for something like a lazy import to complete. Error Boundaries handle the error state. They show a fallback when a component throws an error during rendering. They complement each other and are often used together to provide a complete experience for both loading and error scenarios.</p>
<pre><code class="lang-jsx"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorBoundary</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">p</span>&gt;</span>Something went wrong<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}&gt;
  <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>}&gt;
    <span class="hljs-tag">&lt;<span class="hljs-name">LazyComponent</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ErrorBoundary</span>&gt;</span></span>
</code></pre>
<p>If the lazy component is loading, the <code>Suspense</code> fallback shows. If the lazy component fails to load due to a network error, the Error Boundary catches it and shows the error fallback.</p>
<hr>
<p><strong>Q20: What is Suspense for data fetching?</strong></p>
<p>Suspense for data fetching is an evolving feature where components can suspend while waiting for data, not just lazy-loaded code. Instead of managing loading states manually with <code>useEffect</code> and <code>useState</code>, a component can tell React that it is not ready to render yet, and React shows the nearest <code>Suspense</code> fallback until the data is available.</p>
<p>This is not yet fully stable for arbitrary data fetching in React. However, frameworks like Next.js and libraries like Relay and React Query have started integrating with Suspense for data fetching. The traditional approach of fetching in <code>useEffect</code> and managing <code>loading</code>, <code>error</code>, and <code>data</code> states manually still works and is widely used.</p>
<p>The future vision is that components simply read data and if the data is not available yet, they suspend automatically:</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Future/framework-supported pattern</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserProfile</span>(<span class="hljs-params">{ userId }</span>) </span>{
  <span class="hljs-keyword">const</span> user = use(fetchUser(userId)); <span class="hljs-comment">// Suspends if data not ready</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-comment">// Wrapped in Suspense</span>
&lt;Suspense fallback={&lt;ProfileSkeleton /&gt;}&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserProfile</span> <span class="hljs-attr">userId</span>=<span class="hljs-string">{42}</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
</code></pre>
<hr>
<h2 id="code-splitting">CODE SPLITTING</h2>
<p><strong>Q21: What is code splitting?</strong></p>
<p>Code splitting is the technique of breaking your application&#39;s JavaScript bundle into smaller chunks that can be loaded on demand. By default, bundlers like Webpack or Vite combine all your JavaScript into one or a few large files. As your application grows, this bundle gets larger, increasing the initial load time because the user has to download all the code before anything renders. Code splitting lets you split this bundle so that users only download the code they currently need.</p>
<hr>
<p><strong>Q22: Why is code splitting important for performance?</strong></p>
<p>Without code splitting, a user visiting the home page downloads the code for every other page, every feature, and every library used anywhere in the application, even if they never visit those pages. This wastes bandwidth and delays the initial render. With code splitting, the initial bundle contains only the code needed for the first page. Additional code is fetched in the background or on demand as the user navigates. This reduces the time to first contentful paint, improves the largest contentful paint metric, and provides a faster perceived performance especially on slower networks and devices.</p>
<hr>
<p><strong>Q23: What are the different ways to implement code splitting in React?</strong></p>
<p>There are three primary approaches. Route-based splitting is the most common where each route loads its own chunk using <code>React.lazy</code> and dynamic imports. Component-based splitting is where heavy individual components like a rich text editor or a map are lazy loaded regardless of the route they appear on. Library-based splitting is where large third-party libraries are separated from the main bundle either through dynamic imports or bundler configuration.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// 1. Route-based splitting</span>
<span class="hljs-keyword">const</span> Home = lazy(() =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'./pages/Home'</span>));
<span class="hljs-keyword">const</span> Profile = lazy(() =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'./pages/Profile'</span>));
<span class="hljs-keyword">const</span> Settings = lazy(() =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'./pages/Settings'</span>));

function App() {
  <span class="hljs-keyword">return</span> (
    &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;
      &lt;Routes&gt;
        &lt;Route path=<span class="hljs-string">"/"</span> element={&lt;Home /&gt;} /&gt;
        &lt;Route path=<span class="hljs-string">"/profile"</span> element={&lt;Profile /&gt;} /&gt;
        &lt;Route path=<span class="hljs-string">"/settings"</span> element={&lt;Settings /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Suspense&gt;
  );
}

<span class="hljs-comment">// 2. Component-based splitting</span>
<span class="hljs-keyword">const</span> RichTextEditor = lazy(() =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">'./components/RichTextEditor'</span>));

function PostForm() {
  <span class="hljs-keyword">const</span> [showEditor, setShowEditor] = useState(<span class="hljs-keyword">false</span>);

  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setShowEditor(<span class="hljs-keyword">true</span>)}&gt;Write Post&lt;/button&gt;
      {showEditor &amp;&amp; (
        &lt;Suspense fallback={&lt;p&gt;Loading editor...&lt;/p&gt;}&gt;
          &lt;RichTextEditor /&gt;
        &lt;/Suspense&gt;
      )}
    &lt;/div&gt;
  );
}

<span class="hljs-comment">// 3. Library-based splitting</span>
<span class="hljs-keyword">const</span> handleExport = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> XLSX = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'xlsx'</span>); <span class="hljs-comment">// Large library loaded only when needed</span>
  <span class="hljs-keyword">const</span> worksheet = XLSX.utils.json_to_sheet(data);
  <span class="hljs-comment">// ... export logic</span>
};
</code></pre>
<hr>
<p><strong>Q24: What is the relationship between <code>React.lazy</code>, <code>Suspense</code>, and code splitting?</strong></p>
<p>They work together as a complete solution. Dynamic <code>import()</code> is the JavaScript feature that tells the bundler to split the code at that point and load the module asynchronously at runtime. <code>React.lazy</code> is the React wrapper around dynamic import that makes the loaded module usable as a React component. <code>Suspense</code> is the UI mechanism that shows a fallback while the dynamic import is in progress. The bundler like Webpack or Vite handles the actual splitting of the code into separate files. Together they provide a seamless developer experience where you simply mark a component as lazy and wrap it in Suspense, and the bundler, React, and the browser handle the rest.</p>
<hr>
<p><strong>Q25: How does code splitting work with Webpack or Vite?</strong></p>
<p>When the bundler encounters a dynamic <code>import()</code> expression, it automatically creates a separate chunk file for the imported module and all its dependencies. At runtime, when the code path reaches the dynamic import, the browser fetches the chunk file over the network. Once downloaded, the module is available and the component renders.</p>
<p>Webpack creates files like <code>main.js</code>, <code>0.chunk.js</code>, <code>1.chunk.js</code> where each chunk corresponds to a dynamic import. Vite works similarly but uses native ES modules in development for faster builds and Rollup for production bundling. You do not need any special configuration for basic code splitting. Using <code>import()</code> syntax is enough for both bundlers to automatically split the code.</p>
<hr>
<p><strong>Q26: What is prefetching and preloading in the context of code splitting?</strong></p>
<p>Prefetching means downloading a chunk in the background during idle time before the user actually needs it. Preloading means downloading a chunk immediately alongside the current chunk because it will be needed very soon. Both techniques improve the user experience by reducing or eliminating the loading delay when the user eventually navigates to the prefetched or preloaded route.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Webpack magic comments for prefetch/preload</span>
<span class="hljs-keyword">const</span> About = lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPrefetch: true */</span> <span class="hljs-string">'./pages/About'</span>));
<span class="hljs-comment">// This tells Webpack to add a &lt;link rel="prefetch"&gt; tag, loading About.chunk.js</span>
<span class="hljs-comment">// during browser idle time after the main page loads</span>

<span class="hljs-keyword">const</span> Modal = lazy(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackPreload: true */</span> <span class="hljs-string">'./components/Modal'</span>));
<span class="hljs-comment">// This loads Modal.chunk.js in parallel with the current chunk</span>
<span class="hljs-comment">// Use for components almost certainly needed immediately</span>
</code></pre>
<p>Prefetching is ideal for routes or features the user is likely to visit next, like the next step in a wizard or the most popular pages. Preloading is for resources needed imminently during the current interaction.</p>
<hr>
<h2 id="bonus-performance-questions">BONUS PERFORMANCE QUESTIONS</h2>
<p><strong>Q27: How do you identify performance problems in a React application?</strong></p>
<p>React provides several tools for identifying performance issues. React DevTools Profiler lets you record a session and see which components rendered, how long each render took, and why components re-rendered. The browser&#39;s Performance tab in Chrome DevTools shows the overall JavaScript execution, layout, and paint times. <code>React.StrictMode</code> in development double-renders components to help identify impure renders that could cause issues. The <code>why-did-you-render</code> library can be added to log detailed information about why a component re-rendered. Console logging inside components and effects helps trace render frequency. Lighthouse audits provide overall performance scores and specific recommendations. The key principle is to always measure before optimizing. Premature optimization based on assumptions rather than data often adds complexity without meaningful improvement.</p>
<hr>
<p><strong>Q28: What is the difference between <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code> in terms of what they optimize?</strong></p>
<p><code>React.memo</code> optimizes at the component level. It prevents a component from re-rendering entirely when its props have not changed. The component function body does not execute, no JSX is created, and no diffing happens for that subtree. <code>useMemo</code> optimizes at the computation level inside a component. The component still re-renders and executes, but a specific expensive calculation inside it returns a cached result instead of recalculating. <code>useCallback</code> optimizes at the function reference level. The component still re-renders, but a function defined inside it maintains the same reference across renders, which is primarily useful as a stable prop for memoized child components.</p>
<p>They are often used together. A parent component uses <code>useCallback</code> to stabilize a function prop and <code>useMemo</code> to stabilize an object prop. The child component is wrapped in <code>React.memo</code> so it can actually benefit from the stable references. Using <code>useCallback</code> or <code>useMemo</code> without a <code>React.memo</code> child is often pointless because the child re-renders anyway due to its parent re-rendering.</p>
<hr>
<p><strong>Q29: What is windowing or virtualization and when is it useful?</strong></p>
<p>Windowing or virtualization is a technique where only the items currently visible in the viewport are rendered to the DOM, rather than rendering an entire list of thousands of items. As the user scrolls, items entering the viewport are rendered and items leaving are removed. This dramatically reduces the number of DOM nodes, improving both rendering performance and memory usage.</p>
<p>Libraries like <code>react-window</code> and <code>react-virtuoso</code> implement this pattern. Virtualization is essential when rendering large lists or tables with hundreds or thousands of rows. Without it, the browser struggles with the sheer number of DOM nodes, causing slow initial renders, laggy scrolling, and high memory consumption.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { FixedSizeList } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-window'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VirtualizedList</span>(<span class="hljs-params">{ items }</span>) </span>{
  <span class="hljs-keyword">const</span> Row = <span class="hljs-function">(<span class="hljs-params">{ index, style }</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>
      {items[index].name}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FixedSizeList</span>
      <span class="hljs-attr">height</span>=<span class="hljs-string">{400}</span>
      <span class="hljs-attr">itemCount</span>=<span class="hljs-string">{items.length}</span>
      <span class="hljs-attr">itemSize</span>=<span class="hljs-string">{50}</span>
      <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span>
    &gt;</span>
      {Row}
    <span class="hljs-tag">&lt;/<span class="hljs-name">FixedSizeList</span>&gt;</span></span>
  );
}
</code></pre>
<p>Even if <code>items</code> has 10000 entries, only around 8 to 10 DOM nodes exist at any time.</p>
<hr>
<p><strong>Q30: What is debouncing and throttling and how do they help React performance?</strong></p>
<p>Debouncing delays executing a function until a specified time has passed since the last invocation. If the function is called again before the delay expires, the timer resets. This is useful for search inputs where you want to wait until the user stops typing before making an API call instead of calling the API on every keystroke.</p>
<p>Throttling limits how often a function can execute within a time period. Once the function runs, it cannot run again until the specified time has elapsed regardless of how many times it is triggered. This is useful for scroll and resize event handlers that fire rapidly.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Debounce with custom hook</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useDebounce</span>(<span class="hljs-params">value, delay</span>) </span>{
  <span class="hljs-keyword">const</span> [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setDebouncedValue(value), delay);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> clearTimeout(timer);
  }, [value, delay]);

  <span class="hljs-keyword">return</span> debouncedValue;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchBar</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [query, setQuery] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> debouncedQuery = useDebounce(query, <span class="hljs-number">500</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (debouncedQuery) {
      searchAPI(debouncedQuery); <span class="hljs-comment">// Only called 500ms after user stops typing</span>
    }
  }, [debouncedQuery]);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{query}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> setQuery(e.target.value)} /&gt;;
}</span>
</code></pre>
<p>Without debouncing, typing &quot;react hooks&quot; would trigger 11 API calls, one for each character. With debouncing at 500ms, it triggers only one or two calls after the user pauses.</p>
<hr>
<p><strong>Q31: What are some general best practices for React performance?</strong></p>
<p>Keep component state as local as possible so that state changes re-render only the components that need the updated data. Avoid unnecessary re-renders by using <code>React.memo</code> for expensive child components and stabilizing props with <code>useMemo</code> and <code>useCallback</code>. Use keys correctly in lists so React can efficiently track and update list items. Avoid defining components inside other components because the inner component is recreated on every render, losing all its state. Lazy load routes and heavy components to reduce the initial bundle size. Use virtualization for long lists. Debounce expensive operations triggered by rapid user input. Avoid inline object and array creation in JSX props when passing to memoized children. Move expensive computations to Web Workers if they block the main thread. Use the production build for deployment because the development build includes extra checks and warnings that slow performance. Profile before optimizing and focus on measurable bottlenecks rather than applying micro-optimizations everywhere.</p>
<hr>
<p><strong>Q32: What is the difference between development and production builds in terms of performance?</strong></p>
<p>The development build includes extensive runtime checks, detailed warning messages, React DevTools integration, component stack traces in errors, and in <code>StrictMode</code> double-invocation of certain functions. All of these are helpful during development but add significant overhead. The production build strips out all of these checks and warnings, minifies the code, enables dead code elimination, and optimizes the output for the smallest possible bundle size and fastest execution. A React application in development mode can be noticeably slower than production mode. You should always test performance using the production build and never draw performance conclusions from the development build. Running <code>npm run build</code> or the equivalent creates the production build.</p>
<hr>
<p><strong>Q33: What is reconciliation optimization and how do keys play a role?</strong></p>
<p>During reconciliation React compares the new virtual DOM tree with the previous one to determine the minimum changes needed. Keys are critical for list reconciliation. Without keys or with index-based keys, when an item is added to the beginning of a list, React thinks every item has changed because the indexes shift. With stable unique keys like database IDs, React correctly identifies that the existing items are the same and only the new item needs to be inserted. This dramatically reduces the number of DOM operations for list updates.</p>
<pre><code class="lang-jsx">// ‚ùå Without proper <span class="hljs-built_in">keys</span> ‚Äî inserting at the beginning causes ALL <span class="hljs-built_in">items</span> <span class="hljs-keyword">to</span> re-render
// React sees <span class="hljs-built_in">index</span> <span class="hljs-number">0</span> changed, <span class="hljs-built_in">index</span> <span class="hljs-number">1</span> changed, etc.

// ‚úÖ With stable <span class="hljs-built_in">keys</span> ‚Äî inserting at the beginning <span class="hljs-keyword">only</span> creates ONE <span class="hljs-keyword">new</span> DOM node
// React sees existing <span class="hljs-built_in">keys</span> are unchanged <span class="hljs-built_in">and</span> <span class="hljs-keyword">only</span> the <span class="hljs-keyword">new</span> key <span class="hljs-keyword">is</span> added
{users.<span class="hljs-keyword">map</span>(user =&gt; &lt;UserCard key={user.id} user={user} /&gt;)}
</code></pre>
<p>Proper keys are one of the simplest yet most impactful performance optimizations in React. They require no extra libraries, no hooks, and no complex patterns ‚Äî just using the right identifier.</p>
<hr>
<p><strong>Q34: How does batching improve performance in React?</strong></p>
<p>Batching is React&#39;s mechanism of grouping multiple state updates into a single re-render. Without batching, each <code>setState</code> call would trigger a separate re-render, causing the component to render multiple times for what is logically one update. With batching, React collects all state updates that happen in the same synchronous execution context and applies them in a single re-render.</p>
<p>React 18 introduced automatic batching which extends this behavior to all contexts including promises, setTimeout, native event handlers, and any other asynchronous callbacks. In React 17 and earlier, batching only happened inside React event handlers and lifecycle methods.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>) </span>{
  setName(<span class="hljs-string">'Rahul'</span>);
  setAge(<span class="hljs-number">25</span>);
  setIsActive(<span class="hljs-literal">true</span>);
  <span class="hljs-comment">// React 18: ONE re-render (automatic batching)</span>
  <span class="hljs-comment">// React 17: ONE re-render (inside React event handler)</span>
}

setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  setName(<span class="hljs-string">'Rahul'</span>);
  setAge(<span class="hljs-number">25</span>);
  <span class="hljs-comment">// React 18: ONE re-render (automatic batching)</span>
  <span class="hljs-comment">// React 17: TWO re-renders (outside React event handler, no batching)</span>
}, <span class="hljs-number">1000</span>);
</code></pre>
<p>If you ever need to force a re-render after each state update and opt out of batching, React 18 provides <code>flushSync</code> from <code>react-dom</code>, but this should rarely be needed.</p>
<hr>
<h1 id="-apis-testing-ecosystem-interview-q-a">üîπ APIs, Testing &amp; Ecosystem ‚Äî Interview Q&amp;A</h1>
<hr>
<h2 id="axios-fetch-api">AXIOS / FETCH API</h2>
<p><strong>Q1: What is the Fetch API?</strong></p>
<p>The Fetch API is a built-in browser API for making HTTP requests. It is native to modern browsers and does not require any installation or external dependency. It returns a Promise that resolves to a Response object. You then call methods like <code>.json()</code>, <code>.text()</code>, or <code>.blob()</code> on the response to extract the data. Fetch is the modern replacement for the older <code>XMLHttpRequest</code> (XHR) API.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUsers</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.example.com/users'</span>);

    <span class="hljs-keyword">if</span> (!response.ok) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`HTTP error! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }

    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();
    <span class="hljs-keyword">return</span> data;
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Fetch failed:'</span>, error);
  }
}
</code></pre>
<hr>
<p><strong>Q2: What is Axios?</strong></p>
<p>Axios is a popular third-party HTTP client library for making HTTP requests from both the browser and Node.js. It is Promise-based like Fetch but provides additional features and a more developer-friendly API out of the box. It must be installed via npm or yarn since it is not built into the browser.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUsers</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">'https://api.example.com/users'</span>);
    <span class="hljs-keyword">return</span> response.data; <span class="hljs-comment">// Axios automatically parses JSON</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Request failed:'</span>, error.response?.data || error.message);
  }
}
</code></pre>
<hr>
<p><strong>Q3: What are the key differences between Fetch and Axios?</strong></p>
<p>There are several important differences. With JSON handling, Fetch requires a two-step process where you first get the response and then call <code>.json()</code> to parse it. Axios automatically parses JSON responses and you access the data directly through <code>response.data</code>.</p>
<p>With error handling, Fetch only rejects the Promise on network failures like no internet connection. It does not reject on HTTP error status codes like 404 or 500. You have to manually check <code>response.ok</code> or <code>response.status</code>. Axios automatically rejects the Promise for any HTTP status code outside the 2xx range, making error handling more straightforward.</p>
<p>With request and response interceptors, Axios has a built-in interceptor system where you can globally modify requests before they are sent or responses before they reach your code. Fetch has no built-in interceptor mechanism.</p>
<p>With request cancellation, Axios has built-in cancellation support through <code>CancelToken</code> or the newer <code>AbortController</code>. Fetch supports cancellation through <code>AbortController</code> but requires more manual setup.</p>
<p>With timeout, Axios has a simple <code>timeout</code> configuration option. Fetch has no built-in timeout and you need to implement it manually using <code>AbortController</code> and <code>setTimeout</code>.</p>
<p>With browser support, Fetch is not supported in older browsers like Internet Explorer without a polyfill. Axios works in all browsers including older ones because it falls back to <code>XMLHttpRequest</code>.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Fetch ‚Äî manual error handling</span>
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/api/users'</span>);
<span class="hljs-keyword">if</span> (!response.ok) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Status: <span class="hljs-subst">${response.status}</span>`</span>); <span class="hljs-comment">// Must check manually</span>
}
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json(); <span class="hljs-comment">// Must parse manually</span>

<span class="hljs-comment">// Axios ‚Äî automatic error handling and parsing</span>
<span class="hljs-keyword">const</span> { data } = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">'/api/users'</span>);
<span class="hljs-comment">// Throws automatically on 4xx/5xx</span>
<span class="hljs-comment">// Parses JSON automatically</span>
</code></pre>
<hr>
<p><strong>Q4: What are Axios interceptors and why are they useful?</strong></p>
<p>Interceptors are functions that Axios calls before a request is sent or after a response is received. They let you globally modify requests and responses in one place rather than repeating the same logic in every API call. Common use cases include attaching authentication tokens to every request, logging all requests and responses, globally handling errors like redirecting to login on a 401 unauthorized response, transforming request or response data, and showing or hiding a global loading indicator.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;

// Create an Axios instance
const api = axios.create({
  <span class="hljs-name">baseURL</span>: <span class="hljs-string">'https://api.example.com'</span>,
  <span class="hljs-name">timeout</span>: <span class="hljs-number">10000</span>,
});

// Request interceptor ‚Äî runs before every request
api.interceptors.request.use(
  <span class="hljs-function"><span class="hljs-params">(config)</span> =&gt;</span> {
    const token = localStorage.getItem(<span class="hljs-string">'authToken'</span>);
    <span class="hljs-keyword">if</span> (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    <span class="hljs-keyword">return</span> config;
  },
  <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">error</span>)</span> =&gt;</span> Promise.reject(<span class="hljs-built_in">error</span>)
);

// Response interceptor ‚Äî runs after every response
api.interceptors.response.use(
  <span class="hljs-function"><span class="hljs-params">(response)</span> =&gt;</span> response,
  <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">error</span>)</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">error</span>.response?.status === <span class="hljs-number">401</span>) {
      localStorage.removeItem(<span class="hljs-string">'authToken'</span>);
      window.location.href = <span class="hljs-string">'/login'</span>;
    }
    <span class="hljs-keyword">return</span> Promise.reject(<span class="hljs-built_in">error</span>);
  }
);

<span class="hljs-keyword">export</span> default api;
</code></pre>
<p>Now every API call made through this <code>api</code> instance automatically includes the auth token and handles 401 errors without any additional code in individual components.</p>
<hr>
<p><strong>Q5: How do you cancel an API request in React?</strong></p>
<p>Cancelling requests is important in React because if a component unmounts before the request completes, the response handler might try to update state on an unmounted component. This is a common source of memory leaks and React warnings.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Using Fetch with AbortController</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserProfile</span>(<span class="hljs-params">{ userId }</span>) </span>{
  <span class="hljs-keyword">const</span> [user, setUser] = useState(<span class="hljs-literal">null</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();

    fetch(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>, { <span class="hljs-attr">signal</span>: controller.signal })
      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
      .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> setUser(data))
      .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (err.name !== <span class="hljs-string">'AbortError'</span>) {
          <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Fetch error:'</span>, err);
        }
      });

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> controller.abort(); <span class="hljs-comment">// Cancel on unmount or userId change</span>
  }, [userId]);

  <span class="hljs-keyword">return</span> user ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}

<span class="hljs-comment">// Using Axios with AbortController</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserProfile</span>(<span class="hljs-params">{ userId }</span>) </span>{
  <span class="hljs-keyword">const</span> [user, setUser] = useState(<span class="hljs-literal">null</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();

    axios.get(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>, { <span class="hljs-attr">signal</span>: controller.signal })
      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> setUser(res.data))
      .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (!axios.isCancel(err)) {
          <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Request error:'</span>, err);
        }
      });

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> controller.abort();
  }, [userId]);

  <span class="hljs-keyword">return</span> user ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
}
</code></pre>
<p>The cleanup function in <code>useEffect</code> calls <code>abort()</code> which cancels the in-flight request. If the user rapidly switches between profiles, each navigation cancels the previous request so only the latest one updates the state.</p>
<hr>
<p><strong>Q6: When should you choose Fetch over Axios and vice versa?</strong></p>
<p>Choose Fetch when you want zero dependencies and a smaller bundle size, when you are building a simple application with few API calls, when you are comfortable handling JSON parsing and error checking manually, or when you are working in an environment that already has Fetch polyfilled.</p>
<p>Choose Axios when you need interceptors for global request and response handling, when you want automatic JSON parsing and cleaner error handling, when you need built-in request timeout support, when you are making many API calls and want a consistent and concise API, when you need to support older browsers, or when you want features like request progress tracking for file uploads.</p>
<p>For most production React applications, Axios or a combination of Fetch with a custom wrapper provides a better developer experience. However, Fetch is perfectly adequate for simpler use cases and has the advantage of being built in with no extra dependency.</p>
<hr>
<h2 id="rest-api-integration">REST API INTEGRATION</h2>
<p><strong>Q7: How do you fetch data from a REST API in a React component?</strong></p>
<p>The standard pattern involves using <code>useEffect</code> to trigger the API call when the component mounts or when dependencies change, <code>useState</code> to manage the loading, data, and error states, and an async function inside the effect to perform the actual fetch.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserList</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [users, setUsers] = useState([]);
  <span class="hljs-keyword">const</span> [loading, setLoading] = useState(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">const</span> [error, setError] = useState(<span class="hljs-literal">null</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> fetchUsers = <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-keyword">try</span> {
        setLoading(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'https://api.example.com/users'</span>);

        <span class="hljs-keyword">if</span> (!response.ok) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`HTTP error! Status: <span class="hljs-subst">${response.status}</span>`</span>);
        }

        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json();
        setUsers(data);
      } <span class="hljs-keyword">catch</span> (err) {
        setError(err.message);
      } <span class="hljs-keyword">finally</span> {
        setLoading(<span class="hljs-literal">false</span>);
      }
    };

    fetchUsers();
  }, []);

  <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Error: {error}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      {users.map(user =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span>&gt;</span>{user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
}
</code></pre>
<p>The three states of loading, data, and error cover all possible outcomes of an API call and should always be handled in the UI.</p>
<hr>
<p><strong>Q8: How do you handle different HTTP methods like POST, PUT, and DELETE?</strong></p>
<p>Each HTTP method serves a different purpose in REST APIs. GET retrieves data. POST creates new data. PUT or PATCH updates existing data. DELETE removes data. In React, you typically trigger GET requests in <code>useEffect</code> on mount and trigger POST, PUT, and DELETE requests in response to user actions like form submissions or button clicks.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserManager</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [users, setUsers] = useState([]);

  <span class="hljs-comment">// GET ‚Äî fetch all users on mount</span>
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    fetch(<span class="hljs-string">'/api/users'</span>)
      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
      .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> setUsers(data));
  }, []);

  <span class="hljs-comment">// POST ‚Äî create a new user</span>
  <span class="hljs-keyword">const</span> createUser = <span class="hljs-keyword">async</span> (userData) =&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'/api/users'</span>, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
      <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
      <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(userData),
    });
    <span class="hljs-keyword">const</span> newUser = <span class="hljs-keyword">await</span> response.json();
    setUsers(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> [...prev, newUser]);
  };

  <span class="hljs-comment">// PUT ‚Äî update an existing user</span>
  <span class="hljs-keyword">const</span> updateUser = <span class="hljs-keyword">async</span> (userId, updatedData) =&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">'PUT'</span>,
      <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
      <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(updatedData),
    });
    <span class="hljs-keyword">const</span> updatedUser = <span class="hljs-keyword">await</span> response.json();
    setUsers(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span>
      prev.map(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> (user.id === userId ? updatedUser : user))
    );
  };

  <span class="hljs-comment">// DELETE ‚Äî remove a user</span>
  <span class="hljs-keyword">const</span> deleteUser = <span class="hljs-keyword">async</span> (userId) =&gt; {
    <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span> });
    setUsers(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.id !== userId));
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      {users.map(user =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span>&gt;</span>
          {user.name}
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> deleteUser(user.id)}&gt;Delete<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
}
</code></pre>
<hr>
<p><strong>Q9: What is the best practice for organizing API calls in a React project?</strong></p>
<p>API calls should be abstracted into a separate service layer rather than being written directly inside components. This separation of concerns makes the code more maintainable, reusable, and testable. A common approach is to create an API utility file that configures a base Axios instance or Fetch wrapper, and then create separate service files for each resource or feature.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// api/client.js ‚Äî Base API configuration</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;

<span class="hljs-keyword">const</span> apiClient = axios.create({
  <span class="hljs-attr">baseURL</span>: process.env.REACT_APP_API_URL,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>,
  <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
});

apiClient.interceptors.request.use(<span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> token = localStorage.getItem(<span class="hljs-string">'token'</span>);
  <span class="hljs-keyword">if</span> (token) config.headers.Authorization = <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>;
  <span class="hljs-keyword">return</span> config;
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> apiClient;


<span class="hljs-comment">// api/userService.js ‚Äî User-specific API calls</span>
<span class="hljs-keyword">import</span> apiClient <span class="hljs-keyword">from</span> <span class="hljs-string">'./client'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> userService = {
  <span class="hljs-attr">getAll</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> apiClient.get(<span class="hljs-string">'/users'</span>),
  <span class="hljs-attr">getById</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> apiClient.get(<span class="hljs-string">`/users/<span class="hljs-subst">${id}</span>`</span>),
  <span class="hljs-attr">create</span>: <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> apiClient.post(<span class="hljs-string">'/users'</span>, data),
  <span class="hljs-attr">update</span>: <span class="hljs-function">(<span class="hljs-params">id, data</span>) =&gt;</span> apiClient.put(<span class="hljs-string">`/users/<span class="hljs-subst">${id}</span>`</span>, data),
  <span class="hljs-attr">delete</span>: <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> apiClient.delete(<span class="hljs-string">`/users/<span class="hljs-subst">${id}</span>`</span>),
};


<span class="hljs-comment">// Components just call the service</span>
<span class="hljs-keyword">import</span> { userService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../api/userService'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserList</span>(<span class="hljs-params"></span>) </span>{
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    userService.getAll()
      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> setUsers(res.data))
      .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> setError(err.message));
  }, []);
}
</code></pre>
<p>Components no longer know or care about the base URL, headers, authentication token handling, or the HTTP library being used. If you switch from Axios to Fetch, you only change the service layer.</p>
<hr>
<p><strong>Q10: What is the difference between optimistic and pessimistic UI updates?</strong></p>
<p>Pessimistic updates wait for the server to confirm the operation before updating the UI. The user sees a loading state and the UI updates only after the API response succeeds. This is safer because the UI always reflects the actual server state, but it feels slower because the user waits for the network round trip.</p>
<p>Optimistic updates immediately update the UI as if the operation succeeded and then make the API call in the background. If the API call fails, the UI is rolled back to the previous state. This feels much faster and more responsive because the user sees instant feedback, but it requires handling the rollback case gracefully.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Pessimistic ‚Äî wait for server, then update UI</span>
<span class="hljs-keyword">const</span> deleteUser = <span class="hljs-keyword">async</span> (userId) =&gt; {
  setLoading(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span> });
    setUsers(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.id !== userId)); <span class="hljs-comment">// Update after success</span>
  } <span class="hljs-keyword">catch</span> {
    setError(<span class="hljs-string">'Failed to delete'</span>);
  } <span class="hljs-keyword">finally</span> {
    setLoading(<span class="hljs-literal">false</span>);
  }
};

<span class="hljs-comment">// Optimistic ‚Äî update UI immediately, rollback on failure</span>
<span class="hljs-keyword">const</span> deleteUser = <span class="hljs-keyword">async</span> (userId) =&gt; {
  <span class="hljs-keyword">const</span> previousUsers = users; <span class="hljs-comment">// Save current state for rollback</span>
  setUsers(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> prev.filter(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.id !== userId)); <span class="hljs-comment">// Update immediately</span>

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api/users/<span class="hljs-subst">${userId}</span>`</span>, { <span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span> });
  } <span class="hljs-keyword">catch</span> {
    setUsers(previousUsers); <span class="hljs-comment">// Rollback on failure</span>
    setError(<span class="hljs-string">'Failed to delete. Restored previous state.'</span>);
  }
};
</code></pre>
<p>Optimistic updates are commonly used for actions that almost always succeed like liking a post, toggling a setting, or deleting an item.</p>
<hr>
<p><strong>Q11: What are custom hooks for data fetching and why are they useful?</strong></p>
<p>Creating a custom hook for data fetching encapsulates the repetitive pattern of managing loading, error, and data states along with the actual API call. Instead of duplicating this logic in every component, you write it once and reuse it everywhere.</p>
<pre><code class="lang-jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFetch</span>(<span class="hljs-params">url</span>) </span>{
  <span class="hljs-keyword">const</span> [data, setData] = useState(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [loading, setLoading] = useState(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">const</span> [error, setError] = useState(<span class="hljs-literal">null</span>);

  useEffect(() =&gt; {
    <span class="hljs-keyword">const</span> controller = <span class="hljs-keyword">new</span> AbortController();

    <span class="hljs-keyword">const</span> fetchData = <span class="hljs-keyword">async</span> () =&gt; {
      <span class="hljs-title">try</span> {
        setLoading(<span class="hljs-literal">true</span>);
        setError(<span class="hljs-literal">null</span>);
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-built_in">url</span>, { <span class="hljs-keyword">signal</span><span class="hljs-string"></span>: controller.signal });

        <span class="hljs-keyword">if</span> (!response.ok) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${response.status}</span>`</span>);
        }

        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response.json();
        setData(result);
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">if</span> (err.name !== <span class="hljs-string">'AbortError'</span>) {
          setError(err.message);
        }
      } <span class="hljs-title">finally</span> {
        setLoading(<span class="hljs-literal">false</span>);
      }
    };

    fetchData();

    <span class="hljs-keyword">return</span> () =&gt; controller.abort();
  }, [<span class="hljs-built_in">url</span>]);

  <span class="hljs-keyword">return</span> { data, loading, error };
}

<span class="hljs-comment">// Usage ‚Äî clean and simple</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserList</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-title">const</span> { <span class="hljs-attribute">data</span>: users, loading, error } = useFetch(<span class="hljs-string">'/api/users'</span>);

  <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Spinner</span> /&gt;</span>;</span>
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ErrorMessage</span> <span class="hljs-attr">message</span>=<span class="hljs-string">{error}</span> /&gt;</span>;</span>

  <span class="hljs-keyword">return</span> users.map(user =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserCard</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>)</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ProductList</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-title">const</span> { <span class="hljs-attribute">data</span>: products, loading, error } = useFetch(<span class="hljs-string">'/api/products'</span>);
  <span class="hljs-comment">// Same clean pattern, no duplicate fetch logic</span>
}
</code></pre>
<p>For production applications, libraries like React Query (TanStack Query) or SWR provide battle-tested data fetching hooks with built-in caching, automatic refetching, pagination, infinite scrolling, and optimistic updates out of the box.</p>
<hr>
<h2 id="environment-variables">ENVIRONMENT VARIABLES</h2>
<p><strong>Q12: What are environment variables in a React application?</strong></p>
<p>Environment variables are configuration values that change depending on the environment your application runs in, such as development, staging, or production. They allow you to store values like API base URLs, API keys, feature flags, and third-party service identifiers outside of your source code. This means you can use a different API URL in development than in production without changing any code.</p>
<hr>
<p><strong>Q13: How do you use environment variables in a React app created with Create React App?</strong></p>
<p>In Create React App, environment variables must be prefixed with <code>REACT_APP_</code> to be accessible in the browser. You define them in <code>.env</code> files at the root of your project.</p>
<pre><code><span class="hljs-comment"># .env (default for all environments)</span>
<span class="hljs-attr">REACT_APP_API_URL</span>=https://api.example.com
<span class="hljs-attr">REACT_APP_APP_NAME</span>=MyApp

<span class="hljs-comment"># .env.development (overrides .env in development)</span>
<span class="hljs-attr">REACT_APP_API_URL</span>=http://localhost:<span class="hljs-number">3001</span>

<span class="hljs-comment"># .env.production (overrides .env in production)</span>
<span class="hljs-attr">REACT_APP_API_URL</span>=https://api.production.com

<span class="hljs-comment"># .env.local (local overrides, gitignored)</span>
<span class="hljs-attr">REACT_APP_SECRET_KEY</span>=my-secret-key-<span class="hljs-number">123</span>
</code></pre><p>You access them in your code using <code>process.env</code>:</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">const</span> apiUrl = process.env.REACT_APP_API_URL;
<span class="hljs-keyword">const</span> appName = process.env.REACT_APP_APP_NAME;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    fetch(<span class="hljs-string">`<span class="hljs-subst">${apiUrl}</span>/users`</span>)
      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
      .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> setUsers(data));
  }, []);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{appName}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}
</code></pre>
<hr>
<p><strong>Q14: How do environment variables work in Vite?</strong></p>
<p>In Vite, the prefix is <code>VITE_</code> instead of <code>REACT_APP_</code>. You access them using <code>import.meta.env</code> instead of <code>process.env</code>.</p>
<pre><code><span class="hljs-comment"># .env</span>
<span class="hljs-attr">VITE_API_URL</span>=https://api.example.com
<span class="hljs-attr">VITE_APP_TITLE</span>=My Vite App
</code></pre><pre><code class="lang-jsx"><span class="hljs-keyword">const</span> apiUrl = <span class="hljs-meta"><span class="hljs-meta-keyword">import</span>.meta.env.VITE_API_URL;</span>
<span class="hljs-keyword">const</span> title = <span class="hljs-meta"><span class="hljs-meta-keyword">import</span>.meta.env.VITE_APP_TITLE;</span>
<span class="hljs-keyword">const</span> mode = <span class="hljs-meta"><span class="hljs-meta-keyword">import</span>.meta.env.MODE;</span> <span class="hljs-comment">// 'development' or 'production'</span>
<span class="hljs-keyword">const</span> isDev = <span class="hljs-meta"><span class="hljs-meta-keyword">import</span>.meta.env.DEV;</span> <span class="hljs-comment">// true in development</span>
<span class="hljs-keyword">const</span> isProd = <span class="hljs-meta"><span class="hljs-meta-keyword">import</span>.meta.env.PROD;</span> <span class="hljs-comment">// true in production</span>
</code></pre>
<hr>
<p><strong>Q15: Why must React environment variables have a specific prefix?</strong></p>
<p>The prefix requirement is a security measure. React applications run in the browser where all JavaScript code is visible to anyone. The build tool only embeds variables with the correct prefix into the final bundle. Without this restriction, all environment variables from your system, including sensitive ones like database passwords, SSH keys, or server credentials, could accidentally be included in the client-side bundle and exposed to users. The prefix acts as an explicit opt-in that says you intentionally want this variable to be public.</p>
<hr>
<p><strong>Q16: Are environment variables secure in a React application?</strong></p>
<p>No. Environment variables in a React application are embedded into the JavaScript bundle at build time. They are not truly secret. Anyone can inspect the bundle, open browser DevTools, or view the network requests to see these values. You should never put sensitive secrets like database passwords, private API keys with write access, or encryption keys in client-side environment variables. Values like public API keys, API base URLs, analytics IDs, and feature flags are fine because they are meant to be public. Anything truly secret must be kept on the server and accessed through your own backend API.</p>
<hr>
<p><strong>Q17: When do environment variable changes take effect?</strong></p>
<p>Environment variables are injected at build time, not at runtime. This means if you change a <code>.env</code> file, you must restart the development server or rebuild the application for the changes to take effect. Simply refreshing the browser page will not pick up the new values. In production, you need to create a new build with the updated environment variables.</p>
<hr>
<h2 id="jest">JEST</h2>
<p><strong>Q18: What is Jest?</strong></p>
<p>Jest is a JavaScript testing framework developed by Facebook. It is the default testing framework for React applications created with Create React App. Jest provides a test runner that finds and executes test files, an assertion library with <code>expect</code> and matchers for verifying results, mocking capabilities for replacing dependencies with controlled substitutes, code coverage reporting, snapshot testing for capturing and comparing component output, and a watch mode that automatically re-runs tests when files change. Jest is not React-specific. It can test any JavaScript code. But it is commonly paired with React Testing Library for testing React components.</p>
<hr>
<p><strong>Q19: What is the basic structure of a Jest test?</strong></p>
<p>Jest uses <code>describe</code> to group related tests, <code>test</code> or <code>it</code> to define individual test cases, and <code>expect</code> with matchers to make assertions about the results.</p>
<pre><code class="lang-jsx">// <span class="hljs-built_in">math</span>.js
<span class="hljs-keyword">export</span> function add(a, b) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-keyword">export</span> function multiply(a, b) {
  <span class="hljs-keyword">return</span> a * b;
}


// <span class="hljs-built_in">math</span>.test.js
<span class="hljs-keyword">import</span> { add, multiply } <span class="hljs-keyword">from</span> <span class="hljs-string">'./math'</span>;

describe(<span class="hljs-string">'Math utilities'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  test(<span class="hljs-string">'adds two numbers correctly'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    expect(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).toBe(<span class="hljs-number">5</span>);
    expect(add(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)).toBe(<span class="hljs-number">0</span>);
    expect(add(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)).toBe(<span class="hljs-number">0</span>);
  });

  test(<span class="hljs-string">'multiplies two numbers correctly'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    expect(multiply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).toBe(<span class="hljs-number">6</span>);
    expect(multiply(<span class="hljs-number">-2</span>, <span class="hljs-number">3</span>)).toBe(<span class="hljs-number">-6</span>);
  });

  test(<span class="hljs-string">'add returns a number'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    expect(typeof add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-string">'number'</span>);
  });
});
</code></pre>
<hr>
<p><strong>Q20: What are the commonly used Jest matchers?</strong></p>
<p>Matchers are methods attached to <code>expect()</code> that let you assert different conditions.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Equality</span>
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBe</span>(<span class="hljs-number">5</span>);                      <span class="hljs-comment">// Strict equality (===)</span>
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toEqual</span>({ <span class="hljs-attribute">name</span>: <span class="hljs-string">'Rahul'</span> });   <span class="hljs-comment">// Deep equality for objects/arrays</span>
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.not</span><span class="hljs-selector-class">.toBe</span>(<span class="hljs-number">10</span>);                 <span class="hljs-comment">// Negation</span>

<span class="hljs-comment">// Truthiness</span>
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeTruthy</span>();
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeFalsy</span>();
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeNull</span>();
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeUndefined</span>();
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeDefined</span>();

<span class="hljs-comment">// Numbers</span>
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeGreaterThan</span>(<span class="hljs-number">3</span>);
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeGreaterThanOrEqual</span>(<span class="hljs-number">5</span>);
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeLessThan</span>(<span class="hljs-number">10</span>);
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toBeCloseTo</span>(<span class="hljs-number">0.3</span>);             <span class="hljs-comment">// For floating point</span>

<span class="hljs-comment">// Strings</span>
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toMatch</span>(/pattern/);
<span class="hljs-selector-tag">expect</span>(value)<span class="hljs-selector-class">.toContain</span>(<span class="hljs-string">'substring'</span>);

<span class="hljs-comment">// Arrays</span>
<span class="hljs-selector-tag">expect</span>(array)<span class="hljs-selector-class">.toContain</span>(<span class="hljs-string">'item'</span>);
<span class="hljs-selector-tag">expect</span>(array)<span class="hljs-selector-class">.toHaveLength</span>(<span class="hljs-number">3</span>);

<span class="hljs-comment">// Objects</span>
<span class="hljs-selector-tag">expect</span>(object)<span class="hljs-selector-class">.toHaveProperty</span>(<span class="hljs-string">'name'</span>);
<span class="hljs-selector-tag">expect</span>(object)<span class="hljs-selector-class">.toHaveProperty</span>(<span class="hljs-string">'address.city'</span>, <span class="hljs-string">'Mumbai'</span>);
<span class="hljs-selector-tag">expect</span>(object)<span class="hljs-selector-class">.toMatchObject</span>({ <span class="hljs-attribute">name</span>: <span class="hljs-string">'Rahul'</span> }); <span class="hljs-comment">// Partial match</span>

<span class="hljs-comment">// Exceptions</span>
<span class="hljs-selector-tag">expect</span>(() =&gt; dangerousFunction())<span class="hljs-selector-class">.toThrow</span>();
<span class="hljs-selector-tag">expect</span>(() =&gt; dangerousFunction())<span class="hljs-selector-class">.toThrow</span>(<span class="hljs-string">'specific error message'</span>);

<span class="hljs-comment">// Async</span>
<span class="hljs-selector-tag">await</span> <span class="hljs-selector-tag">expect</span>(asyncFunction())<span class="hljs-selector-class">.resolves</span><span class="hljs-selector-class">.toBe</span>(<span class="hljs-string">'value'</span>);
<span class="hljs-selector-tag">await</span> <span class="hljs-selector-tag">expect</span>(asyncFunction())<span class="hljs-selector-class">.rejects</span><span class="hljs-selector-class">.toThrow</span>(<span class="hljs-string">'error'</span>);
</code></pre>
<hr>
<p><strong>Q21: What are Jest mocks and why are they important?</strong></p>
<p>Mocks are substitute implementations that replace real functions, modules, or API calls during testing. They are important because tests should be isolated and not depend on external systems like APIs, databases, or timers. Mocks let you control what a dependency returns so you can test different scenarios reliably. They also let you verify that functions were called with the correct arguments and the correct number of times.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Mocking a function</span>
<span class="hljs-keyword">const</span> mockCallback = jest.fn();
mockCallback(<span class="hljs-string">'hello'</span>);
mockCallback(<span class="hljs-string">'world'</span>);

expect(mockCallback).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
expect(mockCallback).toHaveBeenCalledWith(<span class="hljs-string">'hello'</span>);
expect(mockCallback).toHaveBeenLastCalledWith(<span class="hljs-string">'world'</span>);

<span class="hljs-comment">// Mocking a return value</span>
<span class="hljs-keyword">const</span> mockFn = jest.fn()
  .mockReturnValueOnce(<span class="hljs-number">10</span>)
  .mockReturnValueOnce(<span class="hljs-number">20</span>)
  .mockReturnValue(<span class="hljs-number">0</span>);

<span class="hljs-built_in">console</span>.log(mockFn()); <span class="hljs-comment">// 10</span>
<span class="hljs-built_in">console</span>.log(mockFn()); <span class="hljs-comment">// 20</span>
<span class="hljs-built_in">console</span>.log(mockFn()); <span class="hljs-comment">// 0</span>

<span class="hljs-comment">// Mocking a module</span>
jest.mock(<span class="hljs-string">'./api/userService'</span>, () =&gt; ({
  <span class="hljs-attribute">getUsers</span>: jest.fn().mockResolvedValue([
    { <span class="hljs-attribute">id:</span><span class="hljs-string"> 1, name</span>: <span class="hljs-string">'Rahul'</span> },
    { <span class="hljs-attribute">id:</span><span class="hljs-string"> 2, name</span>: <span class="hljs-string">'Priya'</span> },
  ]),
}));
</code></pre>
<hr>
<p><strong>Q22: What is snapshot testing in Jest?</strong></p>
<p>Snapshot testing captures the rendered output of a component as a serialized text file and compares it against the stored snapshot on subsequent test runs. If the output changes, the test fails, alerting you to potentially unintended UI changes. You can then review the difference and either fix the bug or update the snapshot if the change was intentional.</p>
<pre><code class="lang-jsx">import renderer <span class="hljs-keyword">from</span> <span class="hljs-string">'react-test-renderer'</span>;

test(<span class="hljs-string">'Button renders correctly'</span>, () =&gt; {
  const tree = renderer.create(
    &lt;Button <span class="hljs-keyword">label</span><span class="bash">=<span class="hljs-string">"Click me"</span> variant=<span class="hljs-string">"primary"</span> /&gt;
</span>  ).toJSON();

  expect(tree).toMatchSnapshot();
});

// First <span class="hljs-keyword">run</span><span class="bash">: creates a .snap file with the serialized output
</span>// Subsequent runs: compares current output with stored snapshot
// If different: test fails
// To update: <span class="hljs-keyword">run</span><span class="bash"> jest --updateSnapshot or press <span class="hljs-string">'u'</span> <span class="hljs-keyword">in</span> watch mode</span>
</code></pre>
<p>Snapshot tests are useful for catching unexpected UI changes but should not be overused. They can become brittle if the component output changes frequently, leading to developers blindly updating snapshots without reviewing the differences.</p>
<hr>
<p><strong>Q23: What is the difference between <code>toBe</code> and <code>toEqual</code>?</strong></p>
<p><code>toBe</code> uses <code>Object.is</code> which is essentially strict equality. It checks if two values are the exact same reference in memory. It works correctly for primitives like numbers, strings, and booleans. For objects and arrays, it only passes if they are literally the same reference, not just having the same contents.</p>
<p><code>toEqual</code> performs a deep equality check. It recursively compares the properties and values of objects and arrays. Two different objects with identical contents will pass <code>toEqual</code> but fail <code>toBe</code>.</p>
<pre><code class="lang-jsx">const obj1 = { <span class="hljs-string">name:</span> <span class="hljs-string">'Rahul'</span>, <span class="hljs-string">age:</span> <span class="hljs-number">25</span> };
const obj2 = { <span class="hljs-string">name:</span> <span class="hljs-string">'Rahul'</span>, <span class="hljs-string">age:</span> <span class="hljs-number">25</span> };

expect(obj1).toBe(obj2);    <span class="hljs-comment">// ‚ùå FAILS ‚Äî different references</span>
expect(obj1).toEqual(obj2);  <span class="hljs-comment">// ‚úÖ PASSES ‚Äî same contents</span>

expect(<span class="hljs-number">5</span>).toBe(<span class="hljs-number">5</span>);           <span class="hljs-comment">// ‚úÖ PASSES ‚Äî same primitive value</span>
expect(<span class="hljs-number">5</span>).toEqual(<span class="hljs-number">5</span>);        <span class="hljs-comment">// ‚úÖ PASSES ‚Äî also works for primitives</span>
</code></pre>
<p>Use <code>toBe</code> for primitives and reference checks. Use <code>toEqual</code> for comparing objects and arrays by their contents.</p>
<hr>
<p><strong>Q24: How do you test asynchronous code with Jest?</strong></p>
<p>Jest supports testing async code through several patterns.</p>
<pre><code class="lang-jsx">// Async/await
test('fetches user data', async () =&gt; {
  const data = await fetchUser(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
  expect(<span class="hljs-name">data</span>.name).toBe('Rahul')<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

// Returning a Promise
test('fetches user data', () =&gt; {
  return fetchUser(<span class="hljs-number">1</span>).then(<span class="hljs-name">data</span> =&gt; {
    expect(<span class="hljs-name">data</span>.name).toBe('Rahul')<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

// Testing rejected Promises
test('handles errors', async () =&gt; {
  await expect(<span class="hljs-name">fetchUser</span>(<span class="hljs-name">-1</span>)).rejects.toThrow('User not found')<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

// Using done callback (<span class="hljs-name">older</span> pattern)
test('callback-based async', (<span class="hljs-name">done</span>) =&gt; {
  fetchUserCallback(<span class="hljs-number">1</span>, (<span class="hljs-name">data</span>) =&gt; {
    expect(<span class="hljs-name">data</span>.name).toBe('Rahul')<span class="hljs-comment">;</span>
    done()<span class="hljs-comment">;</span>
  })<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>The <code>async/await</code> pattern is the most readable and recommended. Make sure to always <code>await</code> async assertions or return the Promise, otherwise the test might pass before the assertion runs.</p>
<hr>
<p><strong>Q25: What are <code>beforeEach</code>, <code>afterEach</code>, <code>beforeAll</code>, and <code>afterAll</code> in Jest?</strong></p>
<p>These are lifecycle hooks for test setup and teardown. <code>beforeEach</code> runs before every individual test in the block. <code>afterEach</code> runs after every individual test. <code>beforeAll</code> runs once before all tests in the block. <code>afterAll</code> runs once after all tests in the block.</p>
<pre><code class="lang-jsx">describe(<span class="hljs-string">'UserService'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> db;

  beforeAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    db = connectToTestDatabase(); <span class="hljs-comment">// Run once before all tests</span>
  });

  afterAll(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    db.disconnect(); <span class="hljs-comment">// Clean up after all tests</span>
  });

  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    db.clear(); <span class="hljs-comment">// Reset database before each test</span>
    db.seed(testData); <span class="hljs-comment">// Insert fresh test data</span>
  });

  afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    jest.restoreAllMocks(); <span class="hljs-comment">// Restore mocked functions after each test</span>
  });

  test(<span class="hljs-string">'creates a user'</span>, () =&gt; { <span class="hljs-comment">/* ... */</span> });
  test(<span class="hljs-string">'deletes a user'</span>, () =&gt; { <span class="hljs-comment">/* ... */</span> });
});
</code></pre>
<p>These hooks ensure tests are isolated and do not affect each other through shared state or leftover side effects.</p>
<hr>
<h2 id="react-testing-library">REACT TESTING LIBRARY</h2>
<p><strong>Q26: What is React Testing Library?</strong></p>
<p>React Testing Library is a testing utility for React that encourages testing components the way users interact with them rather than testing implementation details. It provides utilities to render components, query elements the way a user would find them on screen through text, labels, roles, and placeholders, and simulate user interactions like clicking, typing, and selecting. Its guiding principle is &quot;The more your tests resemble the way your software is used, the more confidence they can give you.&quot;</p>
<hr>
<p><strong>Q27: What is the difference between React Testing Library and Enzyme?</strong></p>
<p>Enzyme was a popular React testing library by Airbnb that focused on testing component internals. It let you access and assert on a component&#39;s state, props, and instance methods. It had methods like <code>shallow</code> rendering that rendered only the component itself without its children. React Testing Library takes the opposite philosophy. It focuses entirely on what the user sees and does. It does not give you access to component state or internal methods. It always fully renders the component with all its children. It encourages finding elements by their accessible roles, text content, and labels rather than by CSS selectors, class names, or component names.</p>
<p>Enzyme is now largely deprecated and no longer actively maintained for newer React versions. React Testing Library is the recommended testing utility by the React team and is included by default in Create React App.</p>
<hr>
<p><strong>Q28: How do you render a component and query elements with React Testing Library?</strong></p>
<p>React Testing Library provides a <code>render</code> function that renders a component into a virtual DOM and returns query functions to find elements.</p>
<pre><code class="lang-jsx">import { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;

function Greeting({ <span class="hljs-built_in">name</span> }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello, {<span class="hljs-built_in">name</span>}!&lt;/h1&gt;
      &lt;p&gt;Welcome <span class="hljs-keyword">to</span> our app&lt;/p&gt;
      &lt;button&gt;Get Started&lt;/button&gt;
      &lt;label htmlFor=<span class="hljs-string">"email"</span>&gt;Email&lt;/label&gt;
      &lt;input id=<span class="hljs-string">"email"</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">"email"</span> placeholder=<span class="hljs-string">"Enter email"</span> /&gt;
    &lt;/div&gt;
  );
}

test(<span class="hljs-string">'renders greeting with user name'</span>, () =&gt; {
  render(&lt;Greeting <span class="hljs-built_in">name</span>=<span class="hljs-string">"Rahul"</span> /&gt;);

  <span class="hljs-comment">// Query by text</span>
  expect(screen.getByText(<span class="hljs-string">'Hello, Rahul!'</span>)).toBeInTheDocument();

  <span class="hljs-comment">// Query by role</span>
  expect(screen.getByRole(<span class="hljs-string">'button'</span>, { <span class="hljs-built_in">name</span>: <span class="hljs-string">'Get Started'</span> })).toBeInTheDocument();
  expect(screen.getByRole(<span class="hljs-string">'heading'</span>)).toHaveTextContent(<span class="hljs-string">'Hello, Rahul!'</span>);

  <span class="hljs-comment">// Query by label</span>
  expect(screen.getByLabelText(<span class="hljs-string">'Email'</span>)).toBeInTheDocument();

  <span class="hljs-comment">// Query by placeholder</span>
  expect(screen.getByPlaceholderText(<span class="hljs-string">'Enter email'</span>)).toBeInTheDocument();

  <span class="hljs-comment">// Query by test ID (last resort)</span>
  <span class="hljs-comment">// expect(screen.getByTestId('custom-element')).toBeInTheDocument();</span>
});
</code></pre>
<hr>
<p><strong>Q29: What is the priority order for queries in React Testing Library?</strong></p>
<p>React Testing Library recommends querying elements in a specific priority order that reflects how users and assistive technologies find elements. The highest priority is <code>getByRole</code> because it queries by ARIA role which is how screen readers and accessibility tools identify elements. Next is <code>getByLabelText</code> which is ideal for form elements. Then <code>getByPlaceholderText</code> for inputs when no label is available. Then <code>getByText</code> for non-interactive elements identified by their visible text. Then <code>getByDisplayValue</code> for form elements with a current value. Then <code>getByAltText</code> for images. Then <code>getByTitle</code> for elements with a title attribute. The lowest priority and last resort is <code>getByTestId</code> which queries by a <code>data-testid</code> attribute. This should only be used when there is no accessible way to query the element.</p>
<p>This priority order encourages writing accessible components because if you cannot find an element using the higher priority queries, it often means the component has accessibility issues.</p>
<hr>
<p><strong>Q30: What are the different types of queries in React Testing Library?</strong></p>
<p>There are three categories of queries, each with a different behavior when the element is not found. <code>getBy</code> queries return the element and throw an error immediately if not found. They are used when you expect the element to be in the document. <code>queryBy</code> queries return the element or <code>null</code> if not found. They are used to assert that an element is NOT present. <code>findBy</code> queries return a Promise that resolves when the element appears in the document. They are used for elements that appear asynchronously after data loading or state changes.</p>
<p>Each category has multi-element variants: <code>getAllBy</code>, <code>queryAllBy</code>, and <code>findAllBy</code> which return arrays of elements.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// getBy ‚Äî element must exist</span>
<span class="hljs-keyword">const</span> button = screen.getByRole(<span class="hljs-string">'button'</span>);

<span class="hljs-comment">// queryBy ‚Äî element may or may not exist</span>
expect(screen.queryByText(<span class="hljs-string">'Error message'</span>)).not.toBeInTheDocument();

<span class="hljs-comment">// findBy ‚Äî element will appear asynchronously</span>
<span class="hljs-keyword">const</span> userName = <span class="hljs-keyword">await</span> screen.findByText(<span class="hljs-string">'Rahul'</span>);

<span class="hljs-comment">// Example testing async loading</span>
test(<span class="hljs-string">'shows users after loading'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  render(&lt;UserList /&gt;);

  <span class="hljs-comment">// Initially shows loading</span>
  expect(screen.getByText(<span class="hljs-string">'Loading...'</span>)).toBeInTheDocument();

  <span class="hljs-comment">// queryBy confirms users are not shown yet</span>
  expect(screen.queryByText(<span class="hljs-string">'Rahul'</span>)).not.toBeInTheDocument();

  <span class="hljs-comment">// findBy waits for async data to load</span>
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> screen.findByText(<span class="hljs-string">'Rahul'</span>);
  expect(user).toBeInTheDocument();

  <span class="hljs-comment">// Loading should be gone</span>
  expect(screen.queryByText(<span class="hljs-string">'Loading...'</span>)).not.toBeInTheDocument();
});
</code></pre>
<hr>
<p><strong>Q31: How do you simulate user interactions in React Testing Library?</strong></p>
<p>React Testing Library provides <code>fireEvent</code> for basic DOM events and the companion library <code>@testing-library/user-event</code> for more realistic user interaction simulation. <code>userEvent</code> is preferred because it simulates the full sequence of events that happen during a real user interaction, including focus, keydown, keypress, input, keyup events for typing.</p>
<pre><code class="lang-jsx">import { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
import userEvent <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/user-event'</span>;

<span class="hljs-function">function <span class="hljs-title">LoginForm</span>(<span class="hljs-params">{ onSubmit }</span>) </span>{
  <span class="hljs-keyword">const</span> [email, setEmail] = useState(<span class="hljs-string">''</span>);
  <span class="hljs-keyword">const</span> [password, setPassword] = useState(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">return</span> (
    &lt;form onSubmit={(e) =&gt; { e.preventDefault(); onSubmit(email, password); }}&gt;
      &lt;label htmlFor=<span class="hljs-string">"email"</span>&gt;Email&lt;/label&gt;
      &lt;input id=<span class="hljs-string">"email"</span> <span class="hljs-keyword">value</span>={email} onChange={e =&gt; setEmail(e.target.<span class="hljs-keyword">value</span>)} /&gt;

      &lt;label htmlFor=<span class="hljs-string">"password"</span>&gt;Password&lt;/label&gt;
      &lt;input id=<span class="hljs-string">"password"</span> type=<span class="hljs-string">"password"</span> <span class="hljs-keyword">value</span>={password}
        onChange={e =&gt; setPassword(e.target.<span class="hljs-keyword">value</span>)} /&gt;

      &lt;button type=<span class="hljs-string">"submit"</span>&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}

test(<span class="hljs-string">'submits the form with user input'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> user = userEvent.setup();
  <span class="hljs-keyword">const</span> mockSubmit = jest.fn();

  render(&lt;LoginForm onSubmit={mockSubmit} /&gt;);

  <span class="hljs-comment">// Type into inputs</span>
  <span class="hljs-keyword">await</span> user.type(screen.getByLabelText(<span class="hljs-string">'Email'</span>), <span class="hljs-string">'rahul@example.com'</span>);
  <span class="hljs-keyword">await</span> user.type(screen.getByLabelText(<span class="hljs-string">'Password'</span>), <span class="hljs-string">'secret123'</span>);

  <span class="hljs-comment">// Click submit</span>
  <span class="hljs-keyword">await</span> user.click(screen.getByRole(<span class="hljs-string">'button'</span>, { name: <span class="hljs-string">'Login'</span> }));

  <span class="hljs-comment">// Assert</span>
  expect(mockSubmit).toHaveBeenCalledTimes(<span class="hljs-number">1</span>);
  expect(mockSubmit).toHaveBeenCalledWith(<span class="hljs-string">'rahul@example.com'</span>, <span class="hljs-string">'secret123'</span>);
});
</code></pre>
<hr>
<p><strong>Q32: How do you test components that make API calls?</strong></p>
<p>You mock the API calls so that tests are predictable, fast, and do not depend on external services. Then you test that the component correctly handles the loading, success, and error states.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;

<span class="hljs-comment">// Mock the API module</span>
jest.mock(<span class="hljs-string">'./api/userService'</span>, () =&gt; ({
  <span class="hljs-attr">getUsers</span>: jest.fn(),
}));

<span class="hljs-keyword">import</span> { getUsers } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api/userService'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserList</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [users, setUsers] = useState([]);
  <span class="hljs-keyword">const</span> [loading, setLoading] = useState(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">const</span> [error, setError] = useState(<span class="hljs-literal">null</span>);

  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    getUsers()
      .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> setUsers(data))
      .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> setError(err.message))
      .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setLoading(<span class="hljs-literal">false</span>));
  }, []);

  <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Error: {error}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>{users.map(u =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{u.id}</span>&gt;</span>{u.name}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)}<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>;
}

test(<span class="hljs-string">'displays users on successful fetch'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  getUsers.mockResolvedValue([
    { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Rahul'</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Priya'</span> },
  ]);

  render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserList</span> /&gt;</span>);

  // Loading state
  expect(screen.getByText('Loading...')).toBeInTheDocument();

  // Wait for data
  expect(await screen.findByText('Rahul')).toBeInTheDocument();
  expect(screen.getByText('Priya')).toBeInTheDocument();

  // Loading gone
  expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
});

test('displays error on failed fetch', async () =&gt; {
  getUsers.mockRejectedValue(new Error('Network error'));

  render(<span class="hljs-tag">&lt;<span class="hljs-name">UserList</span> /&gt;</span>);

  expect(await screen.findByText('Error: Network error')).toBeInTheDocument();
});</span>
</code></pre>
<hr>
<p><strong>Q33: How do you test components that use React Router?</strong></p>
<p>Components that use Router hooks like <code>useParams</code>, <code>useNavigate</code>, or <code>Link</code> need to be wrapped in a Router during testing. React Testing Library does not automatically provide routing context, so you must wrap the component in <code>MemoryRouter</code> which lets you control the initial URL.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> { MemoryRouter, Route, Routes } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> UserProfile <span class="hljs-keyword">from</span> <span class="hljs-string">'./UserProfile'</span>;

test(<span class="hljs-string">'renders user profile with correct userId'</span>, () =&gt; {
  render(
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MemoryRouter</span> <span class="hljs-attr">initialEntries</span>=<span class="hljs-string">{[</span>'/<span class="hljs-attr">users</span>/<span class="hljs-attr">42</span>']}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/users/:userId"</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">UserProfile</span> /&gt;</span>} /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">MemoryRouter</span>&gt;</span>
  );

  expect(screen.getByText('User ID: 42')).toBeInTheDocument();
});</span>
</code></pre>
<p><code>MemoryRouter</code> is preferred over <code>BrowserRouter</code> in tests because it does not interact with the actual browser URL and you can set the initial route through <code>initialEntries</code>.</p>
<hr>
<p><strong>Q34: How do you test components that use Context?</strong></p>
<p>Wrap the component in the Context Provider with the test values you want.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { render, screen } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> { ThemeContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'./ThemeContext'</span>;
<span class="hljs-keyword">import</span> ThemedButton <span class="hljs-keyword">from</span> <span class="hljs-string">'./ThemedButton'</span>;

test(<span class="hljs-string">'renders with dark theme'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  render(
    &lt;ThemeContext.Provider value={{ <span class="hljs-name">theme</span>: <span class="hljs-string">'dark'</span>, <span class="hljs-name">toggleTheme</span>: jest.fn() }}&gt;
      &lt;ThemedButton /&gt;
    &lt;/ThemeContext.Provider&gt;
  );

  expect(screen.getByRole(<span class="hljs-string">'button'</span>)).toHaveClass(<span class="hljs-string">'dark'</span>);
});
</code></pre>
<p>For components that use multiple contexts or require complex setup, creating a custom render function that wraps all providers is a common pattern.</p>
<pre><code class="lang-jsx">// test-utils.js
<span class="hljs-keyword">import</span> { render } from <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> { ThemeContext } from <span class="hljs-string">'./ThemeContext'</span>;
<span class="hljs-keyword">import</span> { AuthContext } from <span class="hljs-string">'./AuthContext'</span>;
<span class="hljs-keyword">import</span> { MemoryRouter } from <span class="hljs-string">'react-router-dom'</span>;

<span class="hljs-keyword">function</span> AllProviders({ children }) {
  return (
    &lt;MemoryRouter&gt;
      &lt;AuthContext.Provider value={{ user: { name: <span class="hljs-string">'Rahul'</span> } }}&gt;
        &lt;ThemeContext.Provider value={{ theme: <span class="hljs-string">'light'</span> }}&gt;
          {children}
        &lt;/ThemeContext.Provider&gt;
      &lt;/AuthContext.Provider&gt;
    &lt;/MemoryRouter&gt;
  );
}

export <span class="hljs-keyword">function</span> renderWithProviders(ui, options) {
  return render(ui, { wrapper: AllProviders, ...options });
}


// In tests
<span class="hljs-keyword">import</span> { renderWithProviders } from <span class="hljs-string">'./test-utils'</span>;

test(<span class="hljs-string">'renders dashboard'</span>, () =&gt; {
  renderWithProviders(&lt;Dashboard /&gt;);
  expect(screen.getByText(<span class="hljs-string">'Welcome, Rahul'</span>)).toBeInTheDocument();
});
</code></pre>
<hr>
<p><strong>Q35: What is the <code>act</code> warning and how do you handle it?</strong></p>
<p>The <code>act</code> warning appears when a state update happens outside of React&#39;s expected flow during a test. React expects all state updates to be wrapped in <code>act()</code> so it can process updates and re-renders before assertions. React Testing Library&#39;s <code>render</code>, <code>fireEvent</code>, and <code>userEvent</code> already wrap things in <code>act</code> automatically. The warning typically appears when there is an asynchronous state update that completes after the test assertions run, like a <code>useEffect</code> that fetches data.</p>
<p>The fix is usually to wait for the async operation to complete before asserting, using <code>findBy</code> queries or <code>waitFor</code>.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { render, screen, waitFor } from <span class="hljs-string">'@testing-library/react'</span>;

<span class="hljs-comment">// ‚ùå Causes act warning ‚Äî assertion runs before async state update</span>
test(<span class="hljs-string">'loads data'</span>, () =&gt; {
  render(&lt;UserList /&gt;);
  expect(screen.getByText(<span class="hljs-string">'Rahul'</span>)).toBeInTheDocument();
});

<span class="hljs-comment">// ‚úÖ Waits for async update to complete</span>
test(<span class="hljs-string">'loads data'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  render(&lt;UserList /&gt;);
  expect(<span class="hljs-keyword">await</span> screen.findByText(<span class="hljs-string">'Rahul'</span>)).toBeInTheDocument();
});

<span class="hljs-comment">// ‚úÖ Using waitFor for more complex assertions</span>
test(<span class="hljs-string">'loads data'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  render(&lt;UserList /&gt;);
  <span class="hljs-keyword">await</span> waitFor(() =&gt; {
    expect(screen.getByText(<span class="hljs-string">'Rahul'</span>)).toBeInTheDocument();
    expect(screen.getAllByRole(<span class="hljs-string">'listitem'</span>)).toHaveLength(<span class="hljs-number">3</span>);
  });
});
</code></pre>
<hr>
<h2 id="bonus-ecosystem-questions">BONUS ECOSYSTEM QUESTIONS</h2>
<p><strong>Q36: What is the difference between unit testing, integration testing, and end-to-end testing in React?</strong></p>
<p>Unit testing tests individual functions, hooks, or small components in complete isolation. Dependencies are mocked. These tests are fast and numerous. Examples include testing a utility function, a custom hook, or a single button component.</p>
<p>Integration testing tests how multiple components work together. Some dependencies might be mocked like API calls but the component tree is rendered more completely. These tests verify that components communicate correctly through props, context, and callbacks. Testing a form that includes input components, validation logic, and a submit button together is an integration test.</p>
<p>End-to-end testing tests the entire application from the user&#39;s perspective, running in a real or simulated browser. Nothing is mocked. The real API, routing, authentication, and database are involved. Tools like Cypress, Playwright, or Selenium are used. These tests are slowest but give the highest confidence.</p>
<p>The testing trophy recommended by Kent C. Dodds, the creator of React Testing Library, suggests writing mostly integration tests, some unit tests, fewer end-to-end tests, and a minimal amount of static analysis through TypeScript and ESLint. Integration tests provide the best balance of confidence and maintenance cost.</p>
<hr>
<p><strong>Q37: What are some common testing mistakes to avoid in React?</strong></p>
<p>Testing implementation details instead of user behavior is the most common mistake. Checking if a state variable has a specific value or if an internal function was called is fragile and breaks when you refactor. Instead, test what the user sees and does.</p>
<p>Over-relying on snapshot tests leads to developers blindly updating snapshots without reviewing changes. Use snapshots sparingly for stable components.</p>
<p>Not testing error and edge cases means only testing the happy path and missing bugs that occur during loading failures, empty data, or invalid inputs.</p>
<p>Testing library internals like testing that React Router navigated or that Redux dispatched a specific action couples your tests to implementation. Instead test that the correct page or content appeared.</p>
<p>Querying by class names, IDs, or DOM structure is fragile and breaks on refactors. Use accessible queries like <code>getByRole</code> and <code>getByLabelText</code>.</p>
<p>Not cleaning up after tests by forgetting to clear mocks or reset state between tests causes tests to pass or fail depending on execution order.</p>
<hr>
<p><strong>Q38: How do you test custom hooks?</strong></p>
<p>Custom hooks cannot be called outside of a React component. The <code>@testing-library/react</code> library provides a <code>renderHook</code> utility specifically for testing hooks in isolation.</p>
<pre><code class="lang-jsx"><span class="hljs-keyword">import</span> { renderHook, act } <span class="hljs-keyword">from</span> <span class="hljs-string">'@testing-library/react'</span>;
<span class="hljs-keyword">import</span> useCounter <span class="hljs-keyword">from</span> <span class="hljs-string">'./useCounter'</span>;

function useCounter(initialValue = <span class="hljs-number">0</span>) {
  const [count, setCount] = useState(initialValue);
  const increment = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setCount(prev =&gt; prev + <span class="hljs-number">1</span>);
  const decrement = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setCount(prev =&gt; prev - <span class="hljs-number">1</span>);
  const reset = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> setCount(initialValue);
  <span class="hljs-keyword">return</span> { count, increment, decrement, reset };
}

test(<span class="hljs-string">'initializes with default value'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  const { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useCounter());
  expect(result.current.count).toBe(<span class="hljs-number">0</span>);
});

test(<span class="hljs-string">'initializes with provided value'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  const { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useCounter(<span class="hljs-number">10</span>));
  expect(result.current.count).toBe(<span class="hljs-number">10</span>);
});

test(<span class="hljs-string">'increments counter'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  const { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useCounter());

  act(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    result.current.increment();
  });

  expect(result.current.count).toBe(<span class="hljs-number">1</span>);
});

test(<span class="hljs-string">'resets counter'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  const { result } = renderHook(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> useCounter(<span class="hljs-number">5</span>));

  act(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    result.current.increment();
    result.current.increment();
  });
  expect(result.current.count).toBe(<span class="hljs-number">7</span>);

  act(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    result.current.reset();
  });
  expect(result.current.count).toBe(<span class="hljs-number">5</span>);
});
</code></pre>
<hr>
<p><strong>Q39: What file naming conventions does Jest follow for finding test files?</strong></p>
<p>By default, Jest looks for test files in three patterns. Files inside a <code>__tests__</code> folder with any name ending in <code>.js</code>, <code>.jsx</code>, <code>.ts</code>, or <code>.tsx</code>. Files anywhere in the project with a <code>.test.js</code> or <code>.test.tsx</code> suffix. Files anywhere in the project with a <code>.spec.js</code> or <code>.spec.tsx</code> suffix.</p>
<p>The most common convention in React projects is to colocate test files next to the component they test using the <code>.test.js</code> suffix.</p>
<pre><code>src/
  components/
    Button/
      Button<span class="hljs-selector-class">.jsx</span>
      Button<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.jsx</span>
      Button<span class="hljs-selector-class">.module</span><span class="hljs-selector-class">.css</span>
    UserList/
      UserList<span class="hljs-selector-class">.jsx</span>
      UserList<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.jsx</span>
</code></pre><p>Colocation makes it easy to find the test for a component and keeps related files together. When a component is deleted, its test is naturally deleted too.</p>
<hr>
<p><strong>Q40: What is the role of <code>data-testid</code> and when should you use it?</strong></p>
<p><code>data-testid</code> is an HTML attribute you can add to elements specifically for testing purposes. It is queried using <code>screen.getByTestId(&#39;my-id&#39;)</code>. It should be used as a last resort when there is no accessible way to query the element. If an element has no visible text, no label, no ARIA role, and no placeholder, <code>data-testid</code> provides a stable hook for tests that does not change with visual refactors.</p>
<pre><code class="lang-jsx"><span class="hljs-comment">// Only when no accessible query works</span>
&lt;<span class="hljs-keyword">div</span> data-testid=<span class="hljs-string">"loading-spinner"</span> className=<span class="hljs-string">"spinner"</span> /&gt;

<span class="hljs-comment">// In tests</span>
expect(screen.getByTestId(<span class="hljs-string">'loading-spinner'</span>)).toBeInTheDocument();
</code></pre>
<p>Some teams strip <code>data-testid</code> attributes from production builds to keep the HTML clean. This can be done with Babel plugins like <code>babel-plugin-react-remove-properties</code>. However, <code>data-testid</code> adds negligible overhead and many teams leave them in production for easier debugging.</p>
<hr>
</body></html>